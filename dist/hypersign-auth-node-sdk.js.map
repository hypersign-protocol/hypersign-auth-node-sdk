{"version":3,"sources":["webpack://Ae/webpack/universalModuleDefinition","webpack://Ae/webpack/bootstrap","webpack://Ae/./src/config.js","webpack://Ae/./src/utils.js","webpack://Ae/external {\"commonjs\":\"uuid\",\"commonjs2\":\"uuid\"}","webpack://Ae/./src/index.js","webpack://Ae/./src/hsWebsocket.js","webpack://Ae/external {\"commonjs\":\"websocket\",\"commonjs2\":\"websocket\"}","webpack://Ae/./src/store/clientStore.js","webpack://Ae/external \"events\"","webpack://Ae/./src/store/tokenStore.js","webpack://Ae/external {\"commonjs\":\"simple-node-logger\",\"commonjs2\":\"simple-node-logger\"}","webpack://Ae/external {\"commonjs\":\"node-fetch\",\"commonjs2\":\"node-fetch\"}","webpack://Ae/./src/hsAuthService.js","webpack://Ae/external {\"commonjs\":\"jsonwebtoken\",\"commonjs2\":\"jsonwebtoken\"}","webpack://Ae/external {\"commonjs\":\"hs-ssi-sdk\",\"commonjs2\":\"hs-ssi-sdk\"}","webpack://Ae/./src/mail/mail.template.js","webpack://Ae/./src/mail/mail.service.js","webpack://Ae/external {\"commonjs\":\"nodemailer\",\"commonjs2\":\"nodemailer\"}","webpack://Ae/external \"fs\"","webpack://Ae/external \"path\"","webpack://Ae/external \"crypto\""],"names":["root","factory","exports","module","require","define","amd","undefined","global","__WEBPACK_EXTERNAL_MODULE__2__","__WEBPACK_EXTERNAL_MODULE__5__","__WEBPACK_EXTERNAL_MODULE__9__","__WEBPACK_EXTERNAL_MODULE__10__","__WEBPACK_EXTERNAL_MODULE__12__","__WEBPACK_EXTERNAL_MODULE__13__","__WEBPACK_EXTERNAL_MODULE__16__","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","ClientStore","TokenStore","log","getFormatedMessage","clientStore","tokenStore","logger","createSimpleLogger","logFilePath","timestampFormat","setLevel","on","args","clientId","time","connection","getClient","setTimeout","sendUTF","emit","e","error","deleteClient","fetch","op","data","JSON","stringify","sanetizeUrl","url","Error","substr","length","async","fetchData","options","resp","json","checkSlash","baseUrl","trim","endsWith","extractToken","req","headers","authorization","split","extractRfToken","refreshtoken","responseMessageFormat","success","message","hypersign","isDate","date","Date","isNaN","HSWebsocket","HypersignAuthService","fs","path","randomUUID","hidNetworkUrls","freeze","testnet","rpc","rest","hsJson","isSubcriptionEnabled","server","offlineSigner","hsFilePath","join","__dirname","hsFilePathDev","hypersignConfig","hsConfigJson","console","existsSync","readFileSync","parse","accessToken","assign","jwt","secret","expiryTime","refreshToken","rft","networkUrl","networkRestUrl","serviceName","appCredential","credentialSubject","schemaId","serviceEp","verifyResourcePath","authResourcePath","keys","namespace","debug","this","mail","hidNodeRestURL","developerDashboardUrl","jwtDefault","rftDefault","ws","did","socketConnTimeOut","initiate","middlewareService","init","res","next","appUserId","authenticate","body","status","send","newtokens","refresh","logout","authToken","userData","authorize","user","isThridPartyAuth","expirationDate","vc","register","query","token","userDid","getCredential","addClient","QRData","getQRData","challenge","tokens","poll","WebSocket","appDid","appName","socketConnectionTimeOut","startsWith","substring","QRType","serviceEndpoint","wss","httpServer","autoAcceptConnections","that","request","accept","origin","JSONData","conn","v4","uuidv4","EventEmitter","Client","isAuthenticated","super","clients","client","updatedClient","store","Map","secs","setSeconds","getSeconds","func","now","getTime","then","diff","Math","max","triggerDelete","toDateTime","delete","set","has","HypersignSSISdk","regMailTemplate","MailService","uuid4","jwtExpiryTime","rftokenExpiryTime","jwtSecret","rftokenSecret","hidNodeURL","developerDashboardVerifyApi","mailService","apiAuthToken","isSubscriptionSuccess","constructorParams","nodeRestEndpoint","nodeRpcEndpoint","hsSdk","hsSdkVC","hsSDKVP","vp","vpObj","holderDidDocSigned","domain","proof","verifiableCredential","holderDidDocSignedtemp","signedPresentation","issuerDid","issuer","holderVerificationMethodId","verificationMethod","issuerVerificationMethodId","holderDid","id","result","verify","verified","didDoc","issuerKeys","subjectDidDocSigned","publicKey","fields","subjectDid","credential","generate","verificationMethodId","signOptions","privateKeyMultibase","registerCredential","signedCredential","issue","txn_message","generateRegisterCredentialStatusTxnMessage","credentialStatus","credentialStatusProof","presentation","generatePresentation","signPresentation","privateKeyBase58","method","callSubscriptionAPIwithPresentation","developerPortalAPI","appUserID","checkSubscription","subject","verifyPresentation","sign","expiresIn","updateClient","payload","verifyRefreshToken","refToken","generateCredential","link","mailTemplate","replace","JSONdata","authServerOrigin","URL","deepLinkUrl","encodeURI","email","sendEmail","nodemailer","host","port","pass","transporter","createTransport","secure","auth","err","to","sendMail","from","html"],"mappings":"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","file":"hypersign-auth-node-sdk.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"uuid\"), require(\"websocket\"), require(\"simple-node-logger\"), require(\"node-fetch\"), require(\"jsonwebtoken\"), require(\"hs-ssi-sdk\"), require(\"nodemailer\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([, , , , , , ], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Ae\"] = factory(require(\"uuid\"), require(\"websocket\"), require(\"simple-node-logger\"), require(\"node-fetch\"), require(\"jsonwebtoken\"), require(\"hs-ssi-sdk\"), require(\"nodemailer\"));\n\telse\n\t\troot[\"Ae\"] = factory(root[undefined], root[undefined], root[undefined], root[undefined], root[undefined], root[undefined], root[undefined]);\n})(global, function(__WEBPACK_EXTERNAL_MODULE__2__, __WEBPACK_EXTERNAL_MODULE__5__, __WEBPACK_EXTERNAL_MODULE__9__, __WEBPACK_EXTERNAL_MODULE__10__, __WEBPACK_EXTERNAL_MODULE__12__, __WEBPACK_EXTERNAL_MODULE__13__, __WEBPACK_EXTERNAL_MODULE__16__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","const ClientStore = require('./store/clientStore')\nconst TokenStore = require('./store/tokenStore')\nconst log = require(\"simple-node-logger\")\n\nconst { getFormatedMessage } =  require('./utils');\n\nconst clientStore = new ClientStore();\nconst tokenStore = new TokenStore();\n\n// LOGGING\nconst log_path = \"hypersign-auth.log\";\n\nconst logger = log.createSimpleLogger({\n    logFilePath: log_path,\n    timestampFormat: \"YYYY-MM-DD HH:mm:ss.SSS\"\n});\n\nlogger.setLevel(\"debug\");\n  \n\nclientStore.on('startTimer', (args) => {\n    try{\n        const { clientId, time } = args;\n        const { connection } = clientStore.getClient(clientId)\n        setTimeout(() => {\n            if(connection) connection.sendUTF(getFormatedMessage('reload', { clientId }));\n            clientStore.emit('deleteClient', { clientId });\n        }, time)        \n    }catch(e){\n        logger.error(e);\n    }\n})\n\nclientStore.on('deleteClient', (args) => {\n    try{\n        const { clientId } =  args;\n        clientStore.deleteClient(clientId);\n    }catch(e){\n        logger.error(e);\n    }\n})\n\nmodule.exports = {\n    clientStore,\n    tokenStore,\n    logger\n}","const fetch = require('node-fetch');\n\nexport function getFormatedMessage(op, data) {\n    return JSON.stringify({\n        op,\n        data\n    })\n}\n\nexport function sanetizeUrl(url) {\n    if (!url) throw new Error(\"Url is empty\");\n    if (url.substr(url.length - 1) == '/') {\n        return url.substr(0, url.length - 1)\n    } else return url;\n}\n\n\nexport async function fetchData(url, options) {\n    const resp = await fetch(url, options)\n    const json = await resp.json();\n    return json;\n}\n\nexport function checkSlash(baseUrl) {\n    if (!baseUrl) throw new Error(\"HS-AUTH-NODE-SDK:: Error: baseUrl is null or empty\");\n    baseUrl = baseUrl.trim();\n    if (!baseUrl.endsWith('/'))\n        return baseUrl + '/';\n    else\n        return baseUrl;\n}\n\nexport function extractToken(req) {\n    if (req.headers.authorization && req.headers.authorization.split(' ')[0] === 'Bearer') {\n        return req.headers.authorization.split(' ')[1];\n    }\n    return null;\n}\n\nexport function extractRfToken(req) {\n    // TODO:  need to find out what is the proper way of sending a refresh token, \n    // we are sending via \"refresh_token\": \"Bearer <Refresh token>\" header\n    if (req.headers.refreshtoken && req.headers.refreshtoken.split(' ')[0] === 'Bearer') {\n        return req.headers.refreshtoken.split(' ')[1];\n    }\n    return null;\n}\n\n\nexport function responseMessageFormat(success, message, data = {}) {\n    return {\n        hypersign: {\n            success,\n            message,\n            data\n        }\n    }\n}\n\nexport function isDate (date){\n    return (new Date(date) !== \"Invalid Date\") && !isNaN(new Date(date));\n}","module.exports = __WEBPACK_EXTERNAL_MODULE__2__;","const HSWebsocket = require('./hsWebsocket');\nconst HypersignAuthService = require('./hsAuthService');\nconst fs = require('fs');\nconst path = require('path');\nconst { clientStore, logger } = require('./config');\nconst { extractToken, extractRfToken, responseMessageFormat, isDate } = require('./utils');\nconst { randomUUID } = require('crypto');\n\nconst HYPERSIGN_CONFIG_FILE = 'hypersign.json';\n\n\nconst hidNetworkUrls = Object.freeze({\n    testnet: {\n        rpc: 'https://rpc.prajna.hypersign.id/',\n        rest: 'https://api.prajna.hypersign.id/',\n    }\n})\n\n\nconst hsJson = {\n    \"networkUrl\": \"https://rpc.prajna.hypersign.id/\",\n    \"networkRestUrl\": \"https://api.prajna.hypersign.id/\",\n    \"jwt\": {\n        \"secret\": \"00c2c433-a077-4e68-b19c-1234f014a510\",\n        \"expiryTime\": 120000\n    },\n    \"rft\": {\n        \"secret\": \"00c2c433-a077-4e68-b19c-1234f014a510\",\n        \"expiryTime\": 120000\n    },\n    \"appCredential\": {\n        \"credentialSubject\": {\n            \"name\": \"Entity Developer Dashboard\",\n            \"did\": \"did:hid:testnet:z8uyZoEA2JTCMWfadrSPaqyWmwzwc3qAwAM4snVrfLKue\",\n            \"owner\": \"did:hid:testnet:z8uyZoEA2JTCMWfadrSPaqyWmwzwc3qAwAM4snVrfLKue\",\n            \"schemaId\": \"sch:hid:testnet:zufjU7LuQuJNFiUpuhCwYkTrakUu1VmtxE9SPi5TwfUB:1.0\",\n            \"serviceEp\": \"http://localhost:3002\",\n            \"verifyResourcePath\": \"\",\n            \"id\": \"did:hid:testnet:z8uyZoEA2JTCMWfadrSPaqyWmwzwc3qAwAM4snVrfLKue\",\n        }\n    },\n    \"namespace\": \"testnet\",\n    isSubcriptionEnabled: false,\n}\n\n\nmodule.exports = class HypersignAuth {\n\n    constructor(server, offlineSigner, options = {}) {\n        ////\n        // Making it backward compatible\n        const hsFilePath = path.join(__dirname, '../../../', HYPERSIGN_CONFIG_FILE);\n        const hsFilePathDev = path.join(  HYPERSIGN_CONFIG_FILE)\n\n        console.log({\n            hsFilePath, hsFilePathDev\n        })\n\n        console.log({\n            hsFilePath: fs.existsSync(hsFilePath),\n            hsFilePathDev: fs.existsSync(hsFilePathDev)\n        })\n        let hypersignConfig;\n        let hsConfigJson;\n        if ( !fs.existsSync(hsFilePathDev)) {\n            if (options.accessToken) {\n                Object.assign(hsJson.jwt, options.accessToken)\n            } else {\n                hsJson.jwt.secret = randomUUID()\n                hsJson.jwt.expiryTime = 120000\n            }\n\n            if (options.refreshToken) {\n                Object.assign(hsJson.rft, options.refreshToken)\n            } else {\n                hsJson.rft.secret = randomUUID()\n                hsJson.rft.expiryTime = 120000\n            }\n\n            if (options.networkUrl && options.networkUrl != '') {\n                hsJson.networkUrl = options.networkUrl\n            } else {\n                hsJson.networkUrl = hidNetworkUrls.testnet.rpc\n            }\n\n            if (options.networkRestUrl && options.networkRestUrl != \"\") {\n                hsJson.networkRestUrl = options.networkRestUrl\n            } else {\n                hsJson.networkRestUrl = hidNetworkUrls.testnet.rest\n            }\n\n            if (options.serviceName && options.serviceName != \"\") {\n                hsJson.appCredential.credentialSubject.name = options.serviceName\n            } else {\n                throw new Error(\"serviceName property is required\")\n            }\n\n            if (options.schemaId && options.schemaId != \"\") {\n                hsJson.appCredential.credentialSubject.schemaId = options.schemaId\n            } else {\n                throw new Error(\"schemaId property is required\")\n            }\n\n            if (options.serviceEp && options.serviceEp != \"\") {\n                hsJson.appCredential.credentialSubject.serviceEp = options.serviceEp\n            } else {\n                throw new Error(\"serviceEp property is required\")\n            }\n\n            if (options.verifyResourcePath) {\n                hsJson.appCredential.credentialSubject.verifyResourcePath = options.verifyResourcePath\n            }\n\n\n\n            hsConfigJson = hsJson;\n        } else {\n\n            hypersignConfig = fs.readFileSync(HYPERSIGN_CONFIG_FILE);\n            hsConfigJson = JSON.parse(hypersignConfig);\n        }\n\n        // TODO: we can delete this later. this is to make backward compatibility\n        hsConfigJson.appCredential.credentialSubject.authResourcePath = !hsConfigJson.appCredential.credentialSubject.authResourcePath ? \"hs/api/v2/auth\" : hsConfigJson.appCredential.credentialSubject.authResourcePath;\n        hsConfigJson.appCredential.credentialSubject.baseUrl = !hsConfigJson.appCredential.credentialSubject.baseUrl ? hsConfigJson.appCredential.credentialSubject.serviceEp : hsConfigJson.appCredential.credentialSubject.baseUrl;\n\n        if (hsConfigJson.keys == {}) throw new Error('Cryptographic keys is not set');\n        if (hsConfigJson.networkUrl == \"\") throw new Error('Network RPC Url is not set');\n        if (hsConfigJson.networkRestUrl == \"\") throw new Error('Network REST Url is not set');\n        if (hsConfigJson.appCredential == {}) throw new Error('App Credential is not set');\n        if (hsConfigJson.appCredential.credentialSubject == {}) throw new Error('Invalid credentialSubject');\n        if (!hsConfigJson.appCredential.credentialSubject.baseUrl) throw new Error(\"BaseUrl is not present in hypersign.json\");\n        if (!hsConfigJson.appCredential.credentialSubject.authResourcePath) throw new Error(\"AuthResourcePath is not present in hypersign.json\");\n        if (!hsConfigJson.namespace) {\n            logger.debug('DID namespace is not passed. Continuing with mainnet')\n        }\n\n        this.options = {\n            keys: {},\n            mail: {},\n            jwt: {},\n            rft: {},\n            appCredential: {},\n            offlineSigner,\n            namespace: \"\",\n            namespace: \"testnet\"\n        };\n        Object.assign(this.options.mail, hsConfigJson.mail);\n        Object.assign(this.options.keys, hsConfigJson.keys);\n        Object.assign(this.options.appCredential, hsConfigJson.appCredential);\n\n        this.options.networkUrl = hsConfigJson.networkUrl;\n        this.options.hidNodeRestURL = hsConfigJson.networkRestUrl;\n        this.options.namespace = hsConfigJson.namespace;\n\n        this.options.schemaId = hsConfigJson.appCredential.credentialSubject.schemaId;\n        this.options.developerDashboardUrl = hsConfigJson.developerDashboardUrl ? hsConfigJson.developerDashboardUrl : 'https://ssi.hypermine.in/developer/';\n\n        if (!hsConfigJson.jwt) {\n            const jwtDefault = {\n                secret: randomUUID(),\n                expiryTime: '900s' // epires in 15 mins\n            }\n            Object.assign(this.options.jwt, jwtDefault)\n            logger.debug('AccessToken configuration not passed. Taking default configuration.. Secret = ' + jwtDefault.secret + ' ExpiryTime = ' + jwtDefault.expiryTime)\n        } else {\n            Object.assign(this.options.jwt, hsConfigJson.jwt)\n        }\n        if (!hsConfigJson.rft) {\n            const rftDefault = {\n                secret: randomUUID(),\n                expiryTime: '900s' // epires in 15 mins\n            }\n            Object.assign(this.options.rft, rftDefault)\n            logger.debug('Refresh Token configuration not passed. Taking default configuration.. Secret = ' + rftDefault.secret + ' ExpiryTime = ' + rftDefault.expiryTime)\n        } else {\n            Object.assign(this.options.rft, hsConfigJson.rft)\n        }\n\n        this.ws = new HSWebsocket(server,\n            hsConfigJson.appCredential.credentialSubject.baseUrl,\n            hsConfigJson.appCredential.credentialSubject.did,\n            hsConfigJson.appCredential.credentialSubject.name,\n            this.options.schemaId,\n            hsConfigJson.socketConnTimeOut,\n            hsConfigJson.appCredential.credentialSubject.authResourcePath);\n        this.ws.initiate();\n\n        this.options[\"isSubcriptionEnabled\"] = hsConfigJson[\"isSubcriptionEnabled\"] != undefined ? hsConfigJson[\"isSubcriptionEnabled\"] : true;\n\n    }\n\n    async init() {\n        this.middlewareService = new HypersignAuthService(this.options, this.options.appCredential.credentialSubject.baseUrl);\n        await this.middlewareService.init();\n    }\n\n    /**\n     * Authenticate a user by verifying verifiable presentation sent by a user via wallet\n     * @param { Request } req \n     * @param { Response } res \n     * @param { Next } next \n     */\n    async authenticate(req, res, next, appUserId = '') {\n        try {\n            const data = await this.middlewareService.authenticate(req.body, appUserId);\n            Object.assign(req.body, { ...responseMessageFormat(true, \"Authenticated successfully\", { ...data }) });\n            next();\n        } catch (e) {\n            logger.error(e)\n            res.status(401).send(responseMessageFormat(false, e.message));\n        }\n    }\n\n    /**\n     * Generates accessToken and refreshToken pair \n     * Ref: https://www.rfc-editor.org/rfc/rfc6749#section-6\n     * @param { Request } req \n     * @param { Response } res \n     * @param { Next } next  \n     */\n    async refresh(req, res, next) {\n        try {\n            const refreshToken = extractRfToken(req);\n            if (!refreshToken) throw new Error(\"Unauthorized: Refresh Token is not sent in header\")\n\n            const newtokens = await this.middlewareService.refresh(refreshToken);\n            Object.assign(req.body, { ...responseMessageFormat(true, \"New pair of tokens\", { ...newtokens }) });\n            next()\n        } catch (error) {\n            logger.error(error.message)\n            res.status(401).send(responseMessageFormat(false, e.message));\n        }\n    }\n\n    /**\n     * Logs out a user\n     * @param { Request } req \n     * @param { Response } res \n     * @param { Next } next  \n     */\n    async logout(req, res, next) {\n        try {\n            const refreshToken = extractRfToken(req);\n            if (!refreshToken) throw new Error(\"Unauthorized: Refresh Token is not sent in header\")\n\n            await this.middlewareService.logout(refreshToken);\n            // everthing is ok but there is no content\n            res.status(204).send();\n        } catch (error) {\n            logger.error(error.message)\n            res.status(401).send(responseMessageFormat(false, e.message));\n        }\n    }\n\n    /**\n     * Verifies accessToken and returns payload\n     * @param { Request } req \n     * @param { Response } res \n     * @param { Next } next  \n     */\n    async authorize(req, res, next) {\n        try {\n            const authToken = extractToken(req);\n            if (!authToken) throw new Error('Authorization token is not passed in the header')\n            const userData = await this.middlewareService.authorize(authToken)\n            Object.assign(req.body, { ...responseMessageFormat(true, \"Authorized successfully\", { ...userData }) });\n            next();\n        } catch (e) {\n            logger.error(e)\n            res.status(403).send(responseMessageFormat(false, e.message));\n        }\n    }\n\n\n    /**\n     * Registers a new user and sends email\n     * @param { Request } req \n     * @param { Response } res \n     * @param { Next } next \n     */\n    async register(req, res, next) {\n        try {\n            const { user, isThridPartyAuth, expirationDate } = req.body;\n            if (!expirationDate) {\n                return res.status(400).send(responseMessageFormat(false, 'Creadential expirationDate must be passed'));\n            }\n            if (!isDate(expirationDate)) {\n                return res.status(400).send(responseMessageFormat(false, 'Invalid expirationDate; It must be a datetime field'));\n            }\n            if (!user) {\n                return res.status(400).send(responseMessageFormat(false, 'user object is not passed in the body'));\n            }\n            const vc = await this.middlewareService.register(user, isThridPartyAuth ? isThridPartyAuth : false, expirationDate);\n            if (vc) {\n                Object.assign(req.body, { ...responseMessageFormat(true, \"Verifiable Credential\", { ...vc }) });\n            }\n            next();\n        } catch (e) {\n            logger.error(e)\n            res.status(500).send(responseMessageFormat(false, e.message));\n        }\n    }\n\n    /**\n     * Verifies the verifiable credential  JWT and issues auth verifiable credential\n     * @param { Request } req \n     * @param { Response } res \n     * @param { Next } next \n     */\n    async issueCredential(req, res, next) {\n        try {\n            const authToken = req.query.token;\n            const userDid = req.query.did\n            if (!authToken) {\n                return res.status(400).send(responseMessageFormat(false, 'token is not passed in the in query'));\n            }\n\n            if (!userDid) {\n                return res.status(400).send(responseMessageFormat(false, 'did is not passed in the in query'));\n            }\n\n            const vc = await this.middlewareService.getCredential(authToken, userDid);\n            Object.assign(req.body, { ...responseMessageFormat(true, \"Verifiable Credential\", { ...vc }) });\n            next();\n        } catch (e) {\n            logger.error(e)\n            res.status(500).send(responseMessageFormat(false, e.message));\n        }\n    }\n\n    /**\n     * Generates QR data (with challenge) in case the service provider does not want to uee websocket and go with polling\n     * @param { Request } req \n     * @param { Response } res \n     * @param { Next } next  \n     */\n    async challenge(req, res, next) {\n        try {\n            const clientId = clientStore.addClient(null);\n            clientStore.emit('startTimer', { clientId: clientId, time: 120000 });\n            const QRData = this.ws.getQRData(clientId);\n            Object.assign(req.body, { ...responseMessageFormat(true, \"New session data\", QRData) })\n            next();\n        } catch (e) {\n            res.status(400).send(responseMessageFormat(false, e.message));\n        }\n    }\n\n    /**\n     * Call this to check if a user has authenticated or not via wallet\n     * @param { Request } req \n     * @param { Response } res \n     * @param { Next } next  \n     */\n    async poll(req, res, next) {\n        try {\n            let challenge;\n            if (req.query && req.query.challenge) {\n                challenge = req.query.challenge;\n            } else if (req.body && req.body.challenge) {\n                challenge = req.body.challenge;\n            }\n            if (!challenge) {\n                return res.status(400).send(responseMessageFormat(false, \"Challenge is not passed in the request body or query parameter\"))\n            }\n            const tokens = await this.middlewareService.poll({ challenge });\n            Object.assign(req.body, { ...responseMessageFormat(true, 'User is authenticated', { ...tokens }) })\n            next();\n        } catch (e) {\n            res.status(401).send(responseMessageFormat(false, e.message));\n        }\n    }\n\n}","const WebSocket = require('websocket')\nconst { clientStore, logger } = require('./config')\nconst { getFormatedMessage, checkSlash } = require('./utils');\n\n\n\nmodule.exports = class HSWebsocket {\n    constructor(server, baseUrl, appDid, appName, schemaId, socketConnectionTimeOut = 60000, authResourcePath) {\n        if (!server) throw new Error('HS-AUTH-NODE-SDK:: Error: Http server is required.')\n        if (!baseUrl) throw new Error('HS-AUTH-NODE-SDK:: Error: Server baseUrl is required.')\n        this.server = server;\n        this.baseUrl = checkSlash(baseUrl);\n        this.appDid = appDid;\n        this.appName = appName;\n        this.schemaId = schemaId;\n        this.socketConnectionTimeOut = socketConnectionTimeOut;\n        this.authResourcePath = authResourcePath.startsWith(\"/\") ? authResourcePath.substring(1) : authResourcePath;\n    }\n\n    getQRData(challenge) {\n        const JSONData = {\n            QRType: 'REQUEST_CRED',\n            serviceEndpoint: this.baseUrl + this.authResourcePath,\n            schemaId: this.schemaId,\n            appDid: this.appDid,\n            appName: this.appName,\n            challenge\n        }\n\n        return JSONData;\n    }\n\n    initiate() {\n        const wss = new WebSocket.server({\n            httpServer: this.server, // Tieing websocket to HTTP server\n            autoAcceptConnections: false\n        })\n        const that = this;\n        wss.on('request', (request) => {\n            const connection = request.accept(null, request.origin)\n            logger.debug(`HS-AUTH:: Client connected`)\n\n            const clientId = clientStore.addClient(connection);\n            clientStore.emit('startTimer', { clientId: clientId, time: this.socketConnectionTimeOut });\n\n            const JSONData = that.getQRData(clientId);\n\n            connection.sendUTF(getFormatedMessage('init', JSONData));\n            connection.on('message', (m) => {\n\n            })\n            connection.on('close', (conn, clientId) => {\n                if (conn == 4001 && clientId) {\n                    clientStore.emit('deleteClient', { clientId });\n                }\n                logger.debug(`HS-AUTH:: Client disconnected`)\n            })\n        })\n    }\n}","module.exports = __WEBPACK_EXTERNAL_MODULE__5__;","const { v4: uuidv4 } = require('uuid');\nconst EventEmitter = require('events');\n\nclass Client {\n  constructor(connection) {\n    this.clientId = uuidv4();\n    this.connection = connection;\n    this.isAuthenticated = false;\n    this.accessToken = null;\n    this.refreshToken = null;\n  }\n}\n\nmodule.exports = class ClientStore extends EventEmitter {\n  constructor() {\n    super();\n    this.clients = {}; //in-mem store\n  }\n\n  addClient(connection) {\n    // if (!connection) throw new Error('Connection is null')\n    const client = new Client(connection);\n    this.clients[client.clientId] = client;\n    return client.clientId;\n  }\n\n  getClient(clientId) {\n    if (!this.clients[clientId]) throw new Error('HS-AUTH-NODE-SDK:: Error: Invalid challenge');\n    return this.clients[clientId];\n  }\n\n  updateClient(clientId, connection, isAuthenticated, accessToken, refreshToken) {\n    if (!this.clients[clientId]) throw new Error('HS-AUTH-NODE-SDK:: Error: Invalid challenge');\n    let updatedClient = this.clients[clientId];\n    if (connection) updatedClient['connection'] = connection;\n    if (isAuthenticated) updatedClient['isAuthenticated'] = isAuthenticated;\n    if (accessToken) updatedClient['accessToken'] = accessToken;\n    if (refreshToken) updatedClient['refreshToken'] = refreshToken;\n    this.clients[clientId] = updatedClient;\n    return updatedClient;\n  }\n\n  deleteClient(clientId) {\n    //if (!this.clients[clientId]) throw new Error('HS-AUTH-NODE-SDK:: Error: Client does not exist')\n    delete this.clients[clientId];\n    return Object.keys(this.clients).length;\n  }\n\n  getAllClientIds() {\n    return Object.keys(this.clients);\n  }\n};\n","module.exports = require(\"events\");","module.exports = class TokenStore {\n  constructor() {\n    this.store = new Map();\n  }\n\n  // seconds to date\n  toDateTime(secs) {\n    const t = new Date(); // Epoch\n    t.setSeconds(t.getSeconds() + secs);\n    return t;\n  }\n\n  // the reason I had to use this becuase When delay is larger than 2147483647 the delay will be set to 1 since\n  // setTimeout using a 32 bit INT to store the delay so the max value allowed would be 2147483647\n  // Ref: https://stackoverflow.com/questions/3468607/why-does-settimeout-break-for-large-millisecond-delay-values\n  triggerDelete(date, func) {\n    const now = new Date().getTime();\n    const then = date.getTime();\n    const diff = Math.max(then - now, 0);\n    if (diff > 0x7fffffff) {\n      //setTimeout limit is MAX_INT32=(2^31-1)\n      setTimeout(function () {\n        this.triggerDelete(date, func);\n      }, 0x7fffffff);\n    } else {\n      setTimeout(func, diff);\n    }\n  }\n\n  // by default ref token never expires in 30s\n  set(key, value, expiryTime = 30) {\n    this.triggerDelete(this.toDateTime(expiryTime), () => {\n      this.delete(key);\n    });\n    return this.store.set(key, value);\n  }\n\n  get(key) {\n    return this.store.get(key);\n  }\n  has(key) {\n    return this.store.has(key);\n  }\n  delete(key) {\n    return this.store.delete(key);\n  }\n};\n","module.exports = __WEBPACK_EXTERNAL_MODULE__9__;","module.exports = __WEBPACK_EXTERNAL_MODULE__10__;","const jwt = require('jsonwebtoken');\nconst { HypersignSSISdk } = require('hs-ssi-sdk');\nconst regMailTemplate = require('./mail/mail.template');\nconst MailService = require('./mail/mail.service');\nconst { clientStore, tokenStore, logger } = require('./config');\nconst { v4: uuid4 } = require('uuid');\nconst { sanetizeUrl, getFormatedMessage, fetchData, responseMessageFormat } = require('./utils');\n\n\nmodule.exports = class HypersignAuthService {\n\n    constructor(options = {}, baseUrl) {\n        this.options = {};\n        this.options.namespace = options && options.namespace ? options.namespace : '';\n        this.options.jwtExpiryTime = options && options.jwt.expiryTime ? options.jwt.expiryTime : 240000;\n        this.options.rftokenExpiryTime = options && options.rft.expiryTime ? options.rft.expiryTime : 1000;\n        this.options.jwtSecret = options && options.jwt.secret ? options.jwt.secret : 'secretKey';\n        this.options.rftokenSecret = options && options.rft.secret ? options.rft.secret : '8e5507e12da789f3c3bd640711378201d658657999384061bb';\n        this.options.hidNodeURL = options && options.networkUrl ? options.networkUrl : \"http://localhost:26657\"\n        this.options.hidNodeRestURL = options && options.hidNodeRestURL ? options.hidNodeRestURL : \"http://localhost:1317\"\n        this.options.mail = options && options.mail ? options.mail : mail;\n\n        if (!options.offlineSigner) {\n            throw new Error('OfflineSigner is required for initilizing Hypersign Auth Service')\n        }\n        this.options.offlineSigner = options.offlineSigner\n\n        this.baseUrl = baseUrl;\n        this.baseUrl = sanetizeUrl(this.baseUrl);\n        this.options.hidNodeURL = sanetizeUrl(this.options.hidNodeURL)\n        this.options.hidNodeRestURL = sanetizeUrl(this.options.hidNodeRestURL)\n\n        this.options.keys = options.keys;\n\n        // const hsSdk = new hsSdk({ nodeUrl: this.options.hidNodeURL });\n\n\n        this.options.schemaId = options.schemaId;\n\n        this.options.mail = options.mail;\n\n\n        this.options.appCredential = options.appCredential;\n        this.developerDashboardVerifyApi = `${sanetizeUrl(options.developerDashboardUrl)}/hs/api/v2/subscription/verify`;\n        this.mailService = this.options.mail && Object.keys(this.options.mail).length > 0 ? new MailService({ ...this.options.mail }) : null;\n        this.apiAuthToken = \"\";\n        this.isSubscriptionSuccess = false;\n        this.isSubcriptionEnabled = options.isSubcriptionEnabled;\n\n        this.verifyResourcePath = this.options.appCredential.credentialSubject.verifyResourcePath != \"\" ?\n            (this.options.appCredential.credentialSubject.verifyResourcePath.startsWith(\"/\") ? this.options.appCredential.credentialSubject.verifyResourcePath : \"/\" + this.options.appCredential.verifyResourcePath) :\n            \"/hs/api/v2/credential\";\n    }\n\n\n    async init() {\n        const constructorParams = {\n            offlineSigner: this.options.offlineSigner,\n            nodeRestEndpoint: this.options.hidNodeRestURL,\n            nodeRpcEndpoint: this.options.hidNodeURL,\n            namespace: this.options.namespace,\n        };\n\n        const hsSdk = new HypersignSSISdk(constructorParams);\n        await hsSdk.init();\n        this.hsSdkVC = hsSdk.vc;\n        this.hsSDKVP = hsSdk.vp;\n    }\n\n    /**\n     * Verifies VP\n     * @param { Object } vpObj  // verifiable presentation\n     * @param { String } challenge  // challenge\n     * @returns boolean \n     */\n    async verifyPresentation(vpObj, challenge, holderDidDocSigned, domain = 'https://localhos:20202') {\n        if (!vpObj) throw new Error('presentation is null')\n        if (!challenge) throw new Error('challenge is null')\n        console.log(vpObj.proof.domain, \"     \");\n        console.log(vpObj.proof.challenge, \"       \");\n        const vc = vpObj.verifiableCredential[0];\n        domain = vpObj.proof.domain\n        let options\n        if (holderDidDocSigned) {\n            const holderDidDocSignedtemp = JSON.parse(holderDidDocSigned)\n            options = {\n                signedPresentation: vpObj,\n                challenge,\n                domain,\n                issuerDid: vc.issuer,\n                holderDidDocSigned: holderDidDocSignedtemp,\n                holderVerificationMethodId: vpObj.proof.verificationMethod,\n                issuerVerificationMethodId: vc.proof.verificationMethod\n            }\n        } else {\n            options = {\n                signedPresentation: vpObj,\n                challenge,\n                domain,\n                issuerDid: vc.issuer,\n                holderDid: vc.credentialSubject.id,\n                holderVerificationMethodId: vpObj.proof.verificationMethod,\n                issuerVerificationMethodId: vc.proof.verificationMethod\n            }\n        }\n        const result = await this.hsSDKVP.verify(options)\n        const { verified } = result;\n        return verified;\n    }\n\n    /**\n     * Generates verfiable credentials based on userdata \n     * @param { Object } userData \n     * @returns signed VC\n     */\n    async generateCredential(userData, expirationDate, didDoc) {\n        // const schemaUrl = this.options.hidNodeURL + '/api/v1/schema/' + this.options.schemaId;\n        const schemaId = this.options.schemaId;\n        const issuerKeys = this.options.keys;\n        const { did } = userData;\n\n        // removing unwanted fields since they got added by JWT\n        delete userData['iat'];\n        delete userData['exp'];\n        delete userData['did'];\n\n        logger.debug(\"HS-AUTH:: Credential is being generated...\")\n        let options = {}\n        if (didDoc) {\n            options = {\n                schemaId,\n                subjectDidDocSigned: didDoc,\n                issuerDid: issuerKeys.publicKey.id,\n                expirationDate,\n                fields: userData\n            }\n        } else {\n            options = {\n                schemaId,\n                subjectDid: did,\n                issuerDid: issuerKeys.publicKey.id,\n                expirationDate,\n                fields: userData\n            }\n        }\n        const credential = await this.hsSdkVC.generate(options)\n        logger.debug(\"HS-AUTH:: Credential is being signed...\")\n        const verificationMethodId = issuerKeys.publicKey.id + \"#key-1\";\n        const signOptions = {\n            credential,\n            issuerDid: issuerKeys.publicKey.id,\n            privateKeyMultibase: issuerKeys.privateKeyMultibase,\n            verificationMethodId,\n            registerCredential: false,\n        }\n        const signedCredential = await this.hsSdkVC.issue(signOptions)\n        const txn_message = await this.hsSdkVC.generateRegisterCredentialStatusTxnMessage(signedCredential.credentialStatus, signedCredential.credentialStatusProof)\n        signedCredential['txn'] = txn_message\n        return signedCredential\n    }\n\n    /**\n     * Generates verifiable presentation\n     * @returns signed VP\n     */\n    async generatePresentation() {\n        const issuerKeys = this.options.keys;\n        const presentation = await this.hsSdkVC.generatePresentation(\n            this.options.appCredential,\n            issuerKeys.publicKey.id\n        );\n        const challenge = uuid4();\n        const signedPresentation = await this.hsSdkVC.signPresentation(presentation, issuerKeys.publicKey.id, issuerKeys.privateKeyBase58, challenge)\n        return signedPresentation\n    }\n\n    /**\n     * Calls subscription api to check for plan and subscription\n     */\n    async callSubscriptionAPIwithPresentation() {\n        const data = await this.generatePresentation();\n        const json = await fetchData(this.developerDashboardVerifyApi, {\n            method: 'POST',\n            headers: {\n                \"Content-Type\": \"application/json\",\n            },\n            body: JSON.stringify(data)\n        })\n\n        if (json.status == 200) {\n            this.isSubscriptionSuccess = true;\n            this.apiAuthToken = json.message;\n        } else if (json.status == 401) {\n            throw new Error('Unauthorized subscription API access');\n        } else {\n            throw new Error('HS-AUTH-NODE-SDK::Error:' + json.error);\n        }\n    }\n\n    /**\n     * Check for subscription\n     */\n    async checkSubscription() {\n        if (this.apiAuthToken == \"\") {\n            logger.debug('HS-AUTH:: No API Authorization token found, authenticating using verifiable presentation');\n            await this.callSubscriptionAPIwithPresentation();\n        } else {\n            logger.debug('HS-AUTH:: Found API Authorization token, trying to authorize');\n            const developerPortalAPI = `${this.developerDashboardVerifyApi}?apiAuthToken=${this.apiAuthToken}`;\n            const json = await fetchData(developerPortalAPI, {\n                method: 'POST',\n            });\n\n            if (json.status == 200) {\n                this.isSubscriptionSuccess = true;\n            } else if (json.status == 403) {\n                logger.debug('HS-AUTH:: API Authorization token has expired. Trying to authentication again using verifiable presentation');\n                await this.callSubscriptionAPIwithPresentation();\n            } else {\n                throw new Error('HS-AUTH-NODE-SDK::Error:' + json.error);\n            }\n        }\n    }\n\n    /**\n     * Verifies refreshtoken JWT\n     * @param { String } refreshToken \n     * @returns payload\n     */\n    async verifyRefreshToken(refreshToken) {\n        return await jwt.verify(refreshToken, this.options.rftokenSecret)\n    }\n\n    // Public methods\n    /////////////////\n\n    /**\n     * Authenticates user's credentials\n     * @param { object } body \n     * @returns accessToken and refreshToken\n     */\n    async authenticate(body, appUserID = '') {\n        const { challenge, vp, holderDidDocSigned } = body;\n        if (this.isSubcriptionEnabled) {\n            await this.checkSubscription();\n            if (!this.isSubscriptionSuccess) throw new Error('Subscription check unsuccessfull')\n        }\n\n        const vpObj = JSON.parse(vp);\n        const subject = vpObj['verifiableCredential'][0]['credentialSubject'];\n\n        logger.debug(\"HS-AUTH:: Presentation is being verified...\")\n\n        if (!(await this.verifyPresentation(vpObj, challenge, holderDidDocSigned))) throw new Error('Could not verify the presentation')\n\n\n        if (appUserID && appUserID != '') {\n            subject['appUserID'] = appUserID;\n        }\n\n        // TODO:  need to find out if we are missing any imp parameter in the options.\n        // what is the proper way to JWT sign \n        const accessToken = await jwt.sign(subject, this.options.jwtSecret, { expiresIn: this.options.jwtExpiryTime });\n        const refreshToken = await jwt.sign(subject, this.options.rftokenSecret, { expiresIn: this.options.rftokenExpiryTime })\n\n        // TODO:  once we use redis , we can set the expiration time = this.options.rftokenExpiryTime also\n        // but for in-mem, let;s keep it simple\n        await tokenStore.set(subject.id, refreshToken, this.options.rftokenExpiryTime)\n\n        let client = clientStore.getClient(challenge)\n        const tokens = { accessToken, refreshToken }\n        if (client.connection) {\n            client.connection.sendUTF(getFormatedMessage('end', responseMessageFormat(true, 'User is authenticated', tokens)))\n            client = clientStore.updateClient(challenge, client.connection, true, tokens.accessToken, tokens.refreshToken);\n            clientStore.deleteClient(client.clientId);\n        } else {\n            client = clientStore.updateClient(challenge, null, true, tokens.accessToken, tokens.refreshToken);\n        }\n        logger.debug(\"HS-AUTH:: Finished.\")\n        return {\n            user: subject,\n            ...tokens\n        }\n    }\n\n    /**\n     * Verifies old refresh token and generates a new pair\n     * @param { string } refreshToken \n     * @returns accessToken and refreshToken\n     */\n    async refresh(refreshToken) {\n        const payload = await this.verifyRefreshToken(refreshToken)\n\n        // TODO: we need to check if this refresh token was present in the store.\n        const refTokenStored = await tokenStore.get(payload.id)\n\n        if (refTokenStored != refreshToken) {\n            throw new Error(\"Invalid ref token or expired\")\n        }\n\n        delete payload[\"exp\"]\n        delete payload[\"iat\"]\n        const accessToken = await jwt.sign(payload, this.options.jwtSecret, { expiresIn: this.options.jwtExpiryTime })\n        const refToken = await jwt.sign(payload, this.options.rftokenSecret, { expiresIn: this.options.rftokenExpiryTime })\n\n        // TODO::  store the ref token using key value , user did as key\n        // Store the tokens in key val\n        // TODO:  once we use redis , we can set the expiration time = this.options.rftokenExpiryTime also\n        // but for in-mem, let;s keep it simple\n        await tokenStore.set(payload.id, refToken, this.options.rftokenExpiryTime) // the expirey time is in second\n\n        return {\n            accessToken,\n            refreshToken: refToken\n        }\n    }\n\n    /**\n     * Deletes refresh token for that user\n     * @param { string } refreshToken \n     */\n    async logout(refreshToken) {\n        const payload = await this.verifyRefreshToken(refreshToken)\n        // TODO: delete on logout\n        await tokenStore.delete(payload.id)\n    }\n\n    /**\n     * Verifies JWT accessToken\n     * @param { string } authToken \n     * @returns payload\n     */\n    async authorize(authToken) {\n        return await jwt.verify(authToken, this.options.jwtSecret)\n    }\n\n    /**\n     * Geneartes verifiable credential JWT and sends email\n     * @param { object } user \n     * @param { boolean } isThridPartyAuth \n     * @returns null\n     */\n    async register(user, isThridPartyAuth = false, expirationDate, didDoc) {\n        if (!this.mailService) throw new Error(\"Mail configuration is not defined\");\n        if (!this.verifyResourcePath) throw new Error(\"VerifyResourcePath is not set in configuration file\")\n\n        if (!user) throw new Error(\"User object is null or empty.\")\n\n        if (isThridPartyAuth) {\n            const { did } = user;\n\n            if (!did) throw new Error(\"Did must be passed with thirdparty auth request\");\n\n            const verifiableCredential = await this.generateCredential(user, expirationDate, didDoc);\n            return verifiableCredential;\n        }\n\n        const token = await jwt.sign(user, this.options.jwtSecret, { expiresIn: this.options.jwtExpiryTime })\n        let link = `${this.baseUrl}${this.verifyResourcePath}?token=${token}`;\n        let mailTemplate = regMailTemplate;\n        mailTemplate = mailTemplate.replace(/@@APPNAME@@/g, this.options.mail.name);\n        mailTemplate = mailTemplate.replace('@@RECEIVERNAME@@', user.name);\n        mailTemplate = mailTemplate.replace('@@LINK@@', link);\n        const JSONdata = JSON.stringify({\n            QRType: 'ISSUE_CRED',\n            url: link\n        });\n\n        // TODO:  need to remove this hardcoded url\n        const authServerOrigin = (new URL(this.options.hidNodeURL)).origin;\n        const authenticationServerEndPoint = `${authServerOrigin}/hsauth`\n        const deepLinkUrl = encodeURI(`${authenticationServerEndPoint}/deeplink.html?deeplink=hypersign:deeplink?url=${JSONdata}`);\n        mailTemplate = mailTemplate.replace(\"@@DEEPLINKURL@@\", deepLinkUrl);\n\n        if (!user.email) throw new Error(\"No email is passed. Email is required property\");\n        const info = await this.mailService.sendEmail(user.email, mailTemplate, `${this.options.mail.name} Auth Credential Issuance`);\n        return null;\n    }\n\n    /**\n     * Verifies VC JWT and Geneartes verifiable credential\n     * @param { string } token \n     * @param { string } userDid \n     * @returns verifiable credential\n     */\n    async getCredential(token, userDid) {\n        const data = await jwt.verify(token, this.options.jwtSecret)\n        data.did = userDid;\n        const verifiableCredential = await this.generateCredential(data);\n        return verifiableCredential\n    }\n\n    async poll({ challenge }) {\n        if (!challenge) {\n            throw new Error(\"Challenge must be passed\");\n        }\n        let client = clientStore.getClient(challenge);\n        if (!client) {\n            throw new Error(\"Invalid challenge\");\n        }\n        const { isAuthenticated, accessToken, refreshToken } = client;\n        if (isAuthenticated === false) {\n            throw new Error(\"Unauthorized\");\n        }\n\n        clientStore.deleteClient(challenge);\n        return { accessToken, refreshToken };\n    }\n}","module.exports = __WEBPACK_EXTERNAL_MODULE__12__;","module.exports = __WEBPACK_EXTERNAL_MODULE__13__;","const template = `\n<html>\n\n<head>\n    <style>\n        .colored {\n            color: blue;\n        }\n\n        #body {\n            background-color: #80808021\n            font-size: 18px;\n            border: 1px solid #80808021;\n            padding:20px;\n        }\n\n        .center{\n            margin: auto;\n            width: 50%;\n        }\n\n        .mobile {\n            display: none;\n        }\n        .web {\n            display:block;\n        }\n        .button {\n            background-color: #272831;\n            /* blakish */\n            border: none;\n            color: #f1f1f1;\n            border-radius: 8px;\n            padding: 20px;\n            text-align: center;\n            text-decoration: none;\n            font-size: 16px;\n            cursor: pointer;\n            width:30%;\n        }\n\n        @media only screen and (max-device-width : 640px) {\n\n            /* Styles */\n            .mobile {\n                display: block;\n            }\n            .web {\n                display:none;\n            }\n        }\n\n        @media only screen and (max-device-width: 768px) {\n\n            /* Styles */\n            .mobile {\n                display: block;\n            }\n            .web {\n                display:none;\n            }\n        }\n    </style>\n</head>\n\n<body>\n    <div id='body' class=\"center\">\n        <p class='center'><h3>Hi @@RECEIVERNAME@@,</h3></p>\n        <p class='center' style='width:100%'><h5>Welcome to @@APPNAME@@!</h5></p>\n        <p class='colored'>\n            @@APPNAME@@ credential is being issued to you. \n        </p>\n        <p class='colored'>Tap 'Get Credential' button (or link) to receieve the credential in your Hypersign Identity Wallet.</p>\n        <br/>\n        <p><a href='@@DEEPLINKURL@@' class=\"button\">Get credential</a></p>\n        <br/>\n        <br/>\n        <p>Thanks & Regards, <br />Team @@APPNAME@@!</p>\n        <p></p>\n    </div>\n</body>\n\n</html>\n`;\nmodule.exports = template;\n","const nodemailer = require('nodemailer');\nconst { logger } = require('../config');\nmodule.exports = class MailService {\n  constructor({ host, port, user, pass, name }) {\n    this.host = host;\n    this.port = port;\n    this.pass = pass;\n    this.user = user;\n    this.name = name;\n\n    this.transporter = nodemailer.createTransport({\n      host: this.host,\n      port: this.port,\n      secure: true, // true for 465, false for other ports. TODO: find better way to work with it\n      auth: {\n        user: this.user,\n        pass: this.pass,\n      },\n    });\n\n    this.transporter.verify((err, success) => {\n      if (err) console.error(err);\n      logger.debug('HS-AUTH:: Your config is correct');\n    });\n  }\n\n  async sendEmail(to, message, subject) {\n    const info = await this.transporter.sendMail({\n      from: `${this.name} <${this.user}>`,\n      to,\n      subject: 'No reply: ' + subject,\n      html: message,\n    });\n    return info;\n  }\n};\n","module.exports = __WEBPACK_EXTERNAL_MODULE__16__;","module.exports = require(\"fs\");","module.exports = require(\"path\");","module.exports = require(\"crypto\");"],"sourceRoot":""}