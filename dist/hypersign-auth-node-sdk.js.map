{"version":3,"sources":["webpack://Ae/webpack/universalModuleDefinition","webpack://Ae/webpack/bootstrap","webpack://Ae/./src/config.js","webpack://Ae/./src/utils.js","webpack://Ae/external {\"commonjs\":\"uuid\",\"commonjs2\":\"uuid\"}","webpack://Ae/./src/index.js","webpack://Ae/./src/hsWebsocket.js","webpack://Ae/external {\"commonjs\":\"websocket\",\"commonjs2\":\"websocket\"}","webpack://Ae/./src/store/clientStore.js","webpack://Ae/external \"events\"","webpack://Ae/./src/store/tokenStore.js","webpack://Ae/external {\"commonjs\":\"simple-node-logger\",\"commonjs2\":\"simple-node-logger\"}","webpack://Ae/external {\"commonjs\":\"node-fetch\",\"commonjs2\":\"node-fetch\"}","webpack://Ae/./src/hsAuthService.js","webpack://Ae/external {\"commonjs\":\"jsonwebtoken\",\"commonjs2\":\"jsonwebtoken\"}","webpack://Ae/external {\"commonjs\":\"hs-ssi-sdk\",\"commonjs2\":\"hs-ssi-sdk\"}","webpack://Ae/./src/mail/mail.template.js","webpack://Ae/./src/mail/mail.service.js","webpack://Ae/external {\"commonjs\":\"nodemailer\",\"commonjs2\":\"nodemailer\"}","webpack://Ae/external \"fs\"","webpack://Ae/external \"path\""],"names":["root","factory","exports","module","require","define","amd","undefined","global","__WEBPACK_EXTERNAL_MODULE__2__","__WEBPACK_EXTERNAL_MODULE__5__","__WEBPACK_EXTERNAL_MODULE__9__","__WEBPACK_EXTERNAL_MODULE__10__","__WEBPACK_EXTERNAL_MODULE__12__","__WEBPACK_EXTERNAL_MODULE__13__","__WEBPACK_EXTERNAL_MODULE__16__","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","ClientStore","TokenStore","log","getFormatedMessage","clientStore","tokenStore","logger","createSimpleLogger","logFilePath","timestampFormat","setLevel","on","args","clientId","time","connection","getClient","setTimeout","sendUTF","emit","e","error","deleteClient","fetch","op","data","JSON","stringify","sanetizeUrl","url","Error","substr","length","async","fetchData","options","resp","json","checkSlash","baseUrl","trim","endsWith","extractToken","req","headers","authorization","split","extractRfToken","refreshtoken","responseMessageFormat","success","message","hypersign","HSWebsocket","HypersignAuthService","fs","path","server","offlineSigner","hsFilePath","join","__dirname","hsFilePathDev","existsSync","HYPERSIGN_CONFIG_FILE","hypersignConfig","readFileSync","hsConfigJson","parse","appCredential","credentialSubject","authResourcePath","serviceEp","keys","networkUrl","networkRestUrl","this","mail","jwt","rft","assign","hidNodeRestURL","schemaId","developerDashboardUrl","jwtDefault","secret","expiryTime","debug","rftDefault","ws","did","socketConnTimeOut","initiate","middlewareService","init","res","next","authenticate","body","status","send","refreshToken","newtokens","refresh","logout","authToken","userData","authorize","user","isThridPartyAuth","vc","register","query","token","userDid","getCredential","addClient","QRData","getQRData","challenge","tokens","poll","WebSocket","appDid","appName","socketConnectionTimeOut","startsWith","substring","QRType","serviceEndpoint","wss","httpServer","autoAcceptConnections","that","request","accept","origin","JSONData","conn","v4","uuidv4","EventEmitter","Client","isAuthenticated","accessToken","super","clients","client","updatedClient","store","Map","secs","Date","setSeconds","getSeconds","date","func","now","getTime","then","diff","Math","max","triggerDelete","toDateTime","delete","set","has","HypersignSsiSDK","regMailTemplate","MailService","uuid4","jwtExpiryTime","rftokenExpiryTime","jwtSecret","rftokenSecret","hidNodeURL","developerDashboardVerifyApi","mailService","host","apiAuthToken","isSubscriptionSuccess","isSubcriptionEnabled","verifyResourcePath","hsSdk","hsSdkVC","hsSDKVP","vp","vpObj","verifiableCredential","result","verifyPresentation","signedPresentation","domain","issuerDid","issuer","holderDid","id","verified","issuerKeys","subjectDid","publicKey","expirationDate","toISOString","fields","credential","signOptions","privateKey","privateKeyBase58","signCredential","presentation","generatePresentation","signPresentation","method","callSubscriptionAPIwithPresentation","developerPortalAPI","verify","checkSubscription","subject","sign","expiresIn","updateClient","payload","verifyRefreshToken","refToken","generateCredential","link","mailTemplate","replace","JSONdata","authServerOrigin","URL","deepLinkUrl","encodeURI","email","sendEmail","nodemailer","port","pass","transporter","createTransport","secure","auth","err","console","to","sendMail","from","html"],"mappings":"CAAA,SAA2CA,EAAMC,GAC1B,iBAAZC,SAA0C,iBAAXC,OACxCA,OAAOD,QAAUD,EAAQG,QAAQ,QAASA,QAAQ,aAAcA,QAAQ,sBAAuBA,QAAQ,cAAeA,QAAQ,gBAAiBA,QAAQ,cAAeA,QAAQ,eACrJ,mBAAXC,QAAyBA,OAAOC,IAC9CD,OAAO,CAAC,CAAE,CAAE,CAAE,CAAE,CAAE,GAAKJ,GACG,iBAAZC,QACdA,QAAY,GAAID,EAAQG,QAAQ,QAASA,QAAQ,aAAcA,QAAQ,sBAAuBA,QAAQ,cAAeA,QAAQ,gBAAiBA,QAAQ,cAAeA,QAAQ,eAE7KJ,EAAS,GAAIC,EAAQD,OAAKO,GAAYP,OAAKO,GAAYP,OAAKO,GAAYP,OAAKO,GAAYP,OAAKO,GAAYP,OAAKO,GAAYP,OAAKO,IARlI,CASGC,QAAQ,SAASC,EAAgCC,EAAgCC,EAAgCC,EAAiCC,EAAiCC,EAAiCC,GACvN,O,YCTE,IAAIC,EAAmB,GAGvB,SAASC,EAAoBC,GAG5B,GAAGF,EAAiBE,GACnB,OAAOF,EAAiBE,GAAUhB,QAGnC,IAAIC,EAASa,EAAiBE,GAAY,CACzCC,EAAGD,EACHE,GAAG,EACHlB,QAAS,IAUV,OANAmB,EAAQH,GAAUI,KAAKnB,EAAOD,QAASC,EAAQA,EAAOD,QAASe,GAG/Dd,EAAOiB,GAAI,EAGJjB,EAAOD,QA0Df,OArDAe,EAAoBM,EAAIF,EAGxBJ,EAAoBO,EAAIR,EAGxBC,EAAoBQ,EAAI,SAASvB,EAASwB,EAAMC,GAC3CV,EAAoBW,EAAE1B,EAASwB,IAClCG,OAAOC,eAAe5B,EAASwB,EAAM,CAAEK,YAAY,EAAMC,IAAKL,KAKhEV,EAAoBgB,EAAI,SAAS/B,GACX,oBAAXgC,QAA0BA,OAAOC,aAC1CN,OAAOC,eAAe5B,EAASgC,OAAOC,YAAa,CAAEC,MAAO,WAE7DP,OAAOC,eAAe5B,EAAS,aAAc,CAAEkC,OAAO,KAQvDnB,EAAoBoB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQnB,EAAoBmB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKX,OAAOY,OAAO,MAGvB,GAFAxB,EAAoBgB,EAAEO,GACtBX,OAAOC,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOnB,EAAoBQ,EAAEe,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRvB,EAAoB2B,EAAI,SAASzC,GAChC,IAAIwB,EAASxB,GAAUA,EAAOoC,WAC7B,WAAwB,OAAOpC,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAc,EAAoBQ,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRV,EAAoBW,EAAI,SAASiB,EAAQC,GAAY,OAAOjB,OAAOkB,UAAUC,eAAe1B,KAAKuB,EAAQC,IAGzG7B,EAAoBgC,EAAI,GAIjBhC,EAAoBA,EAAoBiC,EAAI,G,kBClFrD,MAAMC,EAAc,EAAQ,GACtBC,EAAa,EAAQ,GACrBC,EAAM,EAAQ,IAEd,mBAAEC,GAAwB,EAAQ,GAElCC,EAAc,IAAIJ,EAClBK,EAAa,IAAIJ,EAKjBK,EAASJ,EAAIK,mBAAmB,CAClCC,YAHa,qBAIbC,gBAAiB,4BAGrBH,EAAOI,SAAS,SAGhBN,EAAYO,GAAG,aAAeC,IAC1B,IACI,MAAM,SAAEC,EAAQ,KAAEC,GAASF,GACrB,WAAEG,GAAeX,EAAYY,UAAUH,GAC7CI,WAAW,KACJF,GAAYA,EAAWG,QAAQf,EAAmB,SAAU,CAAEU,cACjET,EAAYe,KAAK,eAAgB,CAAEN,cACpCC,GACN,MAAMM,GACHd,EAAOe,MAAMD,MAIrBhB,EAAYO,GAAG,eAAiBC,IAC5B,IACI,MAAM,SAAEC,GAAcD,EACtBR,EAAYkB,aAAaT,GAC5B,MAAMO,GACHd,EAAOe,MAAMD,MAIrBpE,EAAOD,QAAU,CACbqD,cACAC,aACAC,W,6BC7CJ,mVAAMiB,EAAQ,EAAQ,IAEf,SAASpB,EAAmBqB,EAAIC,GACnC,OAAOC,KAAKC,UAAU,CAClBH,KACAC,SAID,SAASG,EAAYC,GACxB,IAAKA,EAAK,MAAM,IAAIC,MAAM,gBAC1B,MAAkC,KAA9BD,EAAIE,OAAOF,EAAIG,OAAS,GACjBH,EAAIE,OAAO,EAAGF,EAAIG,OAAS,GACxBH,EAIXI,eAAeC,EAAUL,EAAKM,GACjC,MAAMC,QAAab,EAAMM,EAAKM,GAE9B,aADmBC,EAAKC,OAIrB,SAASC,EAAWC,GACvB,IAAIA,EAAS,MAAM,IAAIT,MAAM,4BAE7B,OADAS,EAAUA,EAAQC,QACLC,SAAS,KAGXF,EAFAA,EAAU,IAKlB,SAASG,EAAaC,GACzB,OAAIA,EAAIC,QAAQC,eAA6D,WAA5CF,EAAIC,QAAQC,cAAcC,MAAM,KAAK,GAC3DH,EAAIC,QAAQC,cAAcC,MAAM,KAAK,GAEzC,KAGJ,SAASC,EAAeJ,GAG3B,OAAIA,EAAIC,QAAQI,cAA2D,WAA3CL,EAAIC,QAAQI,aAAaF,MAAM,KAAK,GACzDH,EAAIC,QAAQI,aAAaF,MAAM,KAAK,GAExC,KAIJ,SAASG,EAAsBC,EAASC,EAAS1B,EAAO,IAC3D,MAAO,CACH2B,UAAW,CACPF,UACAC,UACA1B,W,cCtDZzE,EAAOD,QAAUO,G,gBCAjB,MAAM+F,EAAc,EAAQ,GACtBC,EAAuB,EAAQ,IAC/BC,EAAK,EAAQ,IACbC,EAAO,EAAQ,KACf,YAAEpD,EAAW,OAAEE,GAAW,EAAQ,IAClC,aAAEoC,EAAY,eAAEK,EAAc,sBAAEE,GAA0B,EAAQ,GAKxEjG,EAAOD,QAAU,MAEb,YAAY0G,EAAQC,GAGhB,MAAMC,EAAaH,EAAKI,KAAKC,UAAW,YAPlB,kBAQhBC,EAAgBN,EAAKI,KAAKC,UAAW,MARrB,kBAStB,IAAKN,EAAGQ,WAAWJ,KAAgBJ,EAAGQ,WAAWD,GAAgB,MAAM,IAAIhC,MAAMkC,6GAAwIL,GAEzN,MAAMM,EAAkBV,EAAGW,aAXL,kBAahBC,EAAezC,KAAK0C,MAAMH,GAOhC,GAJAE,EAAaE,cAAcC,kBAAkBC,iBAAoBJ,EAAaE,cAAcC,kBAAkBC,iBAAsCJ,EAAaE,cAAcC,kBAAkBC,iBAAhE,iBACjIJ,EAAaE,cAAcC,kBAAkB/B,QAAW4B,EAAaE,cAAcC,kBAAkB/B,QAAmE4B,EAAaE,cAAcC,kBAAkB/B,QAAtG4B,EAAaE,cAAcC,kBAAkBE,UAGxJL,EAAaM,MAAQ,GAAI,MAAM,IAAI3C,MAAM,iCAC7C,GAA+B,IAA3BqC,EAAaO,WAAkB,MAAM,IAAI5C,MAAM,8BACnD,GAAmC,IAA/BqC,EAAaQ,eAAsB,MAAM,IAAI7C,MAAM,+BACvD,GAAIqC,EAAaE,eAAiB,GAAI,MAAM,IAAIvC,MAAM,6BACtD,GAAIqC,EAAaE,cAAcC,mBAAqB,GAAI,MAAM,IAAIxC,MAAM,6BACxE,IAAKqC,EAAaE,cAAcC,kBAAkB/B,QAAS,MAAM,IAAIT,MAAM,4CAC3E,IAAKqC,EAAaE,cAAcC,kBAAkBC,iBAAkB,MAAM,IAAIzC,MAAM,qDAoBpF,GAlBA8C,KAAKzC,QAAU,CACXsC,KAAM,GACNI,KAAM,GACNC,IAAK,GACLC,IAAK,GACLV,cAAe,GACfX,iBAEJhF,OAAOsG,OAAOJ,KAAKzC,QAAQ0C,KAAMV,EAAaU,MAC9CnG,OAAOsG,OAAOJ,KAAKzC,QAAQsC,KAAMN,EAAaM,MAC9C/F,OAAOsG,OAAOJ,KAAKzC,QAAQkC,cAAeF,EAAaE,eAEvDO,KAAKzC,QAAQuC,WAAaP,EAAaO,WACvCE,KAAKzC,QAAQ8C,eAAiBd,EAAaQ,eAE3CC,KAAKzC,QAAQ+C,SAAWf,EAAaE,cAAcC,kBAAkBY,SACrEN,KAAKzC,QAAQgD,sBAAwBhB,EAAagB,sBAAwBhB,EAAagB,sBAAwB,sCAE1GhB,EAAaW,IAQdpG,OAAOsG,OAAOJ,KAAKzC,QAAQ2C,IAAKX,EAAaW,SAR1B,CACnB,MAAMM,EAAa,CACfC,OAAQ,iBACRC,WAAY,QAEhB5G,OAAOsG,OAAOJ,KAAKzC,QAAQ2C,IAAKM,GAChC9E,EAAOiF,MAAM,mFAAqFH,EAAWC,OAAS,iBAAmBD,EAAWE,YAIxJ,GAAKnB,EAAaY,IAQdrG,OAAOsG,OAAOJ,KAAKzC,QAAQ4C,IAAKZ,EAAaY,SAR1B,CACnB,MAAMS,EAAa,CACfH,OAAQ,iBACRC,WAAY,QAEhB5G,OAAOsG,OAAOJ,KAAKzC,QAAQ4C,IAAKS,GAChClF,EAAOiF,MAAM,6FAA+FC,EAAWH,OAAS,iBAAmBG,EAAWF,YAKlKV,KAAKa,GAAK,IAAIpC,EAAYI,EACtBU,EAAaE,cAAcC,kBAAkB/B,QAC7C4B,EAAaE,cAAcC,kBAAkBoB,IAC7CvB,EAAaE,cAAcC,kBAAkB/F,KAC7CqG,KAAKzC,QAAQ+C,SACbf,EAAawB,kBACbxB,EAAaE,cAAcC,kBAAkBC,kBACjDK,KAAKa,GAAGG,WAERhB,KAAKzC,QAA8B,qBAA4C/E,MAAxC+G,EAAmC,sBAAiBA,EAAmC,qBAIlI,aACIS,KAAKiB,kBAAoB,IAAIvC,EAAqBsB,KAAKzC,QAASyC,KAAKzC,QAAQkC,cAAcC,kBAAkB/B,eACvGqC,KAAKiB,kBAAkBC,OASjC,mBAAmBnD,EAAKoD,EAAKC,GACzB,IACI,MAAMvE,QAAamD,KAAKiB,kBAAkBI,aAAatD,EAAIuD,MAC3DxH,OAAOsG,OAAOrC,EAAIuD,KAAM,IAAIjD,GAAsB,EAAM,6BAA8B,IAAIxB,MAC1FuE,IACF,MAAO5E,GACLd,EAAOe,MAAMD,GACb2E,EAAII,OAAO,KAAKC,KAAKnD,GAAsB,EAAO7B,EAAE+B,WAW5D,cAAcR,EAAKoD,EAAKC,GACpB,IACI,MAAMK,EAAetD,EAAeJ,GACpC,IAAK0D,EAAc,MAAM,IAAIvE,MAAM,qDAEnC,MAAMwE,QAAkB1B,KAAKiB,kBAAkBU,QAAQF,GACvD3H,OAAOsG,OAAOrC,EAAIuD,KAAM,IAAIjD,GAAsB,EAAM,qBAAsB,IAAIqD,MAClFN,IACF,MAAO3E,GACLf,EAAOe,MAAMA,EAAM8B,SACnB4C,EAAII,OAAO,KAAKC,KAAKnD,GAAsB,EAAO7B,EAAE+B,WAU5D,aAAaR,EAAKoD,EAAKC,GACnB,IACI,MAAMK,EAAetD,EAAeJ,GACpC,IAAK0D,EAAc,MAAM,IAAIvE,MAAM,2DAE7B8C,KAAKiB,kBAAkBW,OAAOH,GAEpCN,EAAII,OAAO,KAAKC,OAClB,MAAO/E,GACLf,EAAOe,MAAMA,EAAM8B,SACnB4C,EAAII,OAAO,KAAKC,KAAKnD,GAAsB,EAAO7B,EAAE+B,WAU5D,gBAAgBR,EAAKoD,EAAKC,GACtB,IACI,MAAMS,EAAY/D,EAAaC,GAC/B,IAAK8D,EAAW,MAAM,IAAI3E,MAAM,mDAChC,MAAM4E,QAAiB9B,KAAKiB,kBAAkBc,UAAUF,GACxD/H,OAAOsG,OAAOrC,EAAIuD,KAAM,IAAIjD,GAAsB,EAAM,0BAA2B,IAAIyD,MACvFV,IACF,MAAO5E,GACLd,EAAOe,MAAMD,GACb2E,EAAII,OAAO,KAAKC,KAAKnD,GAAsB,EAAO7B,EAAE+B,WAW5D,eAAeR,EAAKoD,EAAKC,GACrB,IACI,MAAM,KAAEY,EAAI,iBAAEC,GAAqBlE,EAAIuD,KACvC,IAAKU,EACD,OAAOb,EAAII,OAAO,KAAKC,KAAKnD,GAAsB,EAAO,0CAE7D,MAAM6D,QAAWlC,KAAKiB,kBAAkBkB,SAASH,EAAMC,IAAsC,GACzFC,GACApI,OAAOsG,OAAOrC,EAAIuD,KAAM,IAAIjD,GAAsB,EAAM,wBAAyB,IAAI6D,MAEzFd,IACF,MAAO5E,GACLd,EAAOe,MAAMD,GACb2E,EAAII,OAAO,KAAKC,KAAKnD,GAAsB,EAAO7B,EAAE+B,WAU5D,sBAAsBR,EAAKoD,EAAKC,GAC5B,IACI,MAAMS,EAAY9D,EAAIqE,MAAMC,MACtBC,EAAUvE,EAAIqE,MAAMtB,IAC1B,IAAKe,EACD,OAAOV,EAAII,OAAO,KAAKC,KAAKnD,GAAsB,EAAO,wCAG7D,IAAKiE,EACD,OAAOnB,EAAII,OAAO,KAAKC,KAAKnD,GAAsB,EAAO,sCAG7D,MAAM6D,QAAWlC,KAAKiB,kBAAkBsB,cAAcV,EAAWS,GACjExI,OAAOsG,OAAOrC,EAAIuD,KAAM,IAAIjD,GAAsB,EAAM,wBAAyB,IAAI6D,MACrFd,IACF,MAAO5E,GACLd,EAAOe,MAAMD,GACb2E,EAAII,OAAO,KAAKC,KAAKnD,GAAsB,EAAO7B,EAAE+B,WAU5D,gBAAgBR,EAAKoD,EAAKC,GACtB,IACI,MAAMnF,EAAWT,EAAYgH,UAAU,MACvChH,EAAYe,KAAK,aAAc,CAAEN,SAAUA,EAAUC,KAAM,OAC3D,MAAMuG,EAASzC,KAAKa,GAAG6B,UAAUzG,GACjCnC,OAAOsG,OAAOrC,EAAIuD,KAAM,IAAIjD,GAAsB,EAAM,mBAAoBoE,KAC5ErB,IACF,MAAO5E,GACL2E,EAAII,OAAO,KAAKC,KAAKnD,GAAsB,EAAO7B,EAAE+B,WAU5D,WAAWR,EAAKoD,EAAKC,GACjB,IACI,IAAIuB,EAMJ,GALI5E,EAAIqE,OAASrE,EAAIqE,MAAMO,UACvBA,EAAY5E,EAAIqE,MAAMO,UACf5E,EAAIuD,MAAQvD,EAAIuD,KAAKqB,YAC5BA,EAAY5E,EAAIuD,KAAKqB,YAEpBA,EACD,OAAOxB,EAAII,OAAO,KAAKC,KAAKnD,GAAsB,EAAO,mEAE7D,MAAMuE,QAAe5C,KAAKiB,kBAAkB4B,KAAK,CAAEF,cACnD7I,OAAOsG,OAAOrC,EAAIuD,KAAM,IAAIjD,GAAsB,EAAM,wBAAyB,IAAIuE,MACrFxB,IACF,MAAO5E,GACL2E,EAAII,OAAO,KAAKC,KAAKnD,GAAsB,EAAO7B,EAAE+B,c,gBCpQhE,MAAMuE,EAAY,EAAQ,IACpB,YAAEtH,EAAW,OAAEE,GAAW,EAAQ,IAClC,mBAAEH,EAAkB,WAAEmC,GAAgB,EAAQ,GAIpDtF,EAAOD,QAAU,MACb,YAAY0G,EAAQlB,EAASoF,EAAQC,EAAS1C,EAAU2C,EAA0B,IAAOtD,GACrF,IAAKd,EAAQ,MAAM,IAAI3B,MAAM,4BAC7B,IAAKS,EAAS,MAAM,IAAIT,MAAM,+BAC9B8C,KAAKnB,OAASA,EACdmB,KAAKrC,QAAUD,EAAWC,GAC1BqC,KAAK+C,OAASA,EACd/C,KAAKgD,QAAUA,EACfhD,KAAKM,SAAWA,EAChBN,KAAKiD,wBAA0BA,EAC/BjD,KAAKL,iBAAmBA,EAAiBuD,WAAW,KAAOvD,EAAiBwD,UAAU,GAAIxD,EAG9F,UAAUgD,GAUN,MATiB,CACbS,OAAQ,eACRC,gBAAkBrD,KAAKrC,QAAUqC,KAAKL,iBACtCW,SAAUN,KAAKM,SACfyC,OAAQ/C,KAAK+C,OACbC,QAAShD,KAAKgD,QACdL,aAMR,WACI,MAAMW,EAAM,IAAIR,EAAUjE,OAAO,CAC7B0E,WAAYvD,KAAKnB,OACjB2E,uBAAuB,IAErBC,EAAOzD,KACbsD,EAAIvH,GAAG,UAAY2H,IACf,MAAMvH,EAAauH,EAAQC,OAAO,KAAMD,EAAQE,QAChDlI,EAAOiF,MAAM,8BAEb,MAAM1E,EAAWT,EAAYgH,UAAUrG,GACvCX,EAAYe,KAAK,aAAc,CAACN,SAAUA,EAAUC,KAAM8D,KAAKiD,0BAE/D,MAAMY,EAAWJ,EAAKf,UAAUzG,GAEhCE,EAAWG,QAAQf,EAAmB,OAAQsI,IAC9C1H,EAAWJ,GAAG,UAAYvC,OAG1B2C,EAAWJ,GAAG,QAAS,CAAC+H,EAAM7H,KACf,MAAR6H,GAAgB7H,GACfT,EAAYe,KAAK,eAAgB,CAAEN,aAEvCP,EAAOiF,MAAM,wC,cCvD7BvI,EAAOD,QAAUQ,G,gBCAjB,MAAQoL,GAAIC,GAAW,EAAQ,GACzBC,EAAe,EAAQ,GAE7B,MAAMC,EACJ,YAAY/H,GACV6D,KAAK/D,SAAW+H,IAChBhE,KAAK7D,WAAaA,EAClB6D,KAAKmE,iBAAkB,EACvBnE,KAAKoE,YAAc,KACnBpE,KAAKyB,aAAe,MAIxBrJ,EAAOD,QAAU,cAA0B8L,EACzC,cACEI,QACArE,KAAKsE,QAAU,GAGjB,UAAUnI,GAER,MAAMoI,EAAS,IAAIL,EAAO/H,GAE1B,OADA6D,KAAKsE,QAAQC,EAAOtI,UAAYsI,EACzBA,EAAOtI,SAGhB,UAAUA,GACR,IAAK+D,KAAKsE,QAAQrI,GAAW,MAAM,IAAIiB,MAAM,qBAC7C,OAAO8C,KAAKsE,QAAQrI,GAGtB,aAAaA,EAAUE,EAAYgI,EAAiBC,EAAa3C,GAC/D,IAAKzB,KAAKsE,QAAQrI,GAAW,MAAM,IAAIiB,MAAM,qBAC7C,IAAIsH,EAAgBxE,KAAKsE,QAAQrI,GAMjC,OALIE,IAAYqI,EAA0B,WAAIrI,GAC1CgI,IAAiBK,EAA+B,gBAAIL,GACpDC,IAAaI,EAA2B,YAAIJ,GAC5C3C,IAAc+C,EAA4B,aAAI/C,GAClDzB,KAAKsE,QAAQrI,GAAYuI,EAClBA,EAGT,aAAavI,GAGX,cADO+D,KAAKsE,QAAQrI,GACbnC,OAAO+F,KAAKG,KAAKsE,SAASlH,OAGnC,kBACE,OAAOtD,OAAO+F,KAAKG,KAAKsE,Y,cCjD5BlM,EAAOD,QAAUE,QAAQ,W,cCAzBD,EAAOD,QAAU,MACf,cACE6H,KAAKyE,MAAQ,IAAIC,IAInB,WAAWC,GACT,MAAMrK,EAAI,IAAIsK,KAEd,OADAtK,EAAEuK,WAAWvK,EAAEwK,aAAeH,GACvBrK,EAMT,cAAcyK,EAAMC,GAClB,MAAMC,GAAM,IAAIL,MAAOM,UACjBC,EAAOJ,EAAKG,UACZE,EAAOC,KAAKC,IAAIH,EAAOF,EAAK,GAC9BG,EAAO,WAET/I,YAAW,WACT2D,KAAKuF,cAAcR,EAAMC,KACxB,YAEH3I,WAAW2I,EAAMI,GAKrB,IAAIzK,EAAKN,EAAOqG,EAAa,IAI3B,OAHAV,KAAKuF,cAAcvF,KAAKwF,WAAW9E,GAAa,KAC9CV,KAAKyF,OAAO9K,KAEPqF,KAAKyE,MAAMiB,IAAI/K,EAAKN,GAG7B,IAAIM,GACF,OAAOqF,KAAKyE,MAAMxK,IAAIU,GAExB,IAAIA,GACF,OAAOqF,KAAKyE,MAAMkB,IAAIhL,GAExB,OAAOA,GACL,OAAOqF,KAAKyE,MAAMgB,OAAO9K,M,cC5C7BvC,EAAOD,QAAUS,G,cCAjBR,EAAOD,QAAUU,G,gBCAjB,MAAMqH,EAAM,EAAQ,IACd0F,EAAkB,EAAQ,IAC1BC,EAAkB,EAAQ,IAC1BC,EAAc,EAAQ,KACtB,YAAEtK,EAAW,WAAEC,EAAU,OAAEC,GAAW,EAAQ,IAC5CqI,GAAIgC,GAAU,EAAQ,IACxB,YAAE/I,EAAW,mBAAEzB,EAAkB,UAAE+B,EAAS,sBAAEe,GAA0B,EAAQ,GAGtFjG,EAAOD,QAAU,MAEb,YAAYoF,EAAU,GAAII,GAUtB,GATAqC,KAAKzC,QAAU,GACfyC,KAAKzC,QAAQyI,cAAgBzI,GAAWA,EAAQ2C,IAAIQ,WAAanD,EAAQ2C,IAAIQ,WAAa,KAC1FV,KAAKzC,QAAQ0I,kBAAoB1I,GAAWA,EAAQ4C,IAAIO,WAAanD,EAAQ4C,IAAIO,WAAa,IAC9FV,KAAKzC,QAAQ2I,UAAY3I,GAAWA,EAAQ2C,IAAIO,OAASlD,EAAQ2C,IAAIO,OAAS,YAC9ET,KAAKzC,QAAQ4I,cAAgB5I,GAAWA,EAAQ4C,IAAIM,OAASlD,EAAQ4C,IAAIM,OAAS,qDAClFT,KAAKzC,QAAQ6I,WAAa7I,GAAWA,EAAQuC,WAAavC,EAAQuC,WAAa,yBAC/EE,KAAKzC,QAAQ8C,eAAiB9C,GAAWA,EAAQwC,eAAiBxC,EAAQwC,eAAiB,wBAC3FC,KAAKzC,QAAQ0C,KAAO1C,GAAWA,EAAQ0C,KAAO1C,EAAQ0C,KAAOA,MAExD1C,EAAQuB,cACT,MAAM,IAAI5B,MAAM,oEAEpB8C,KAAKzC,QAAQuB,cAAgBvB,EAAQuB,cAErCkB,KAAKrC,QAAUA,EACfqC,KAAKrC,QAAUX,EAAYgD,KAAKrC,SAChCqC,KAAKzC,QAAQ6I,WAAapJ,EAAYgD,KAAKzC,QAAQ6I,YACnDpG,KAAKzC,QAAQ8C,eAAiBrD,EAAYgD,KAAKzC,QAAQ8C,gBAEvDL,KAAKzC,QAAQsC,KAAOtC,EAAQsC,KAK5BG,KAAKzC,QAAQ+C,SAAW/C,EAAQ+C,SAEhCN,KAAKzC,QAAQ0C,KAAO1C,EAAQ0C,KAG5BD,KAAKzC,QAAQkC,cAAgBlC,EAAQkC,cACrCO,KAAKqG,4BAAkCrJ,EAAYO,EAAQgD,uBAAxB,iCAEnCP,KAAKsG,YAActG,KAAKzC,QAAQ0C,MAAkC,IAA1BD,KAAKzC,QAAQ0C,KAAKsG,KAAa,IAAIT,EAAY,IAAI9F,KAAKzC,QAAQ0C,OAAU,KAGlHD,KAAKwG,aAAe,GACpBxG,KAAKyG,uBAAwB,EAC7BzG,KAAK0G,qBAAuBnJ,EAAQmJ,qBAEpC1G,KAAK2G,mBAAwF,IAAnE3G,KAAKzC,QAAQkC,cAAcC,kBAAkBiH,mBAClE3G,KAAKzC,QAAQkC,cAAcC,kBAAkBiH,mBAAmBzD,WAAW,KAAOlD,KAAKzC,QAAQkC,cAAcC,kBAAkBiH,mBAAqB,IAAM3G,KAAKzC,QAAQkC,cAAckH,mBACtL,wBAIR,aACI,MAAMC,EAAQ,IAAIhB,EAAgB5F,KAAKzC,QAAQuB,cAAekB,KAAKzC,QAAQ6I,WAAYpG,KAAKzC,QAAQ8C,sBAC9FuG,EAAM1F,OACZlB,KAAK6G,QAAUD,EAAM1E,GACrBlC,KAAK8G,QAAUF,EAAMG,GASzB,yBAAyBC,EAAOrE,GAC5B,IAAKqE,EAAO,MAAM,IAAI9J,MAAM,wBAC5B,IAAKyF,EAAW,MAAM,IAAIzF,MAAM,qBAChC,MAAMgF,EAAK8E,EAAMC,qBAAqB,GAChCC,QAAelH,KAAK8G,QAAQK,mBAAmB,CACjDC,mBAAoBJ,EACpBrE,YACA0E,OAAQ,yBACRC,UAAWpF,EAAGqF,OACdC,UAAWtF,EAAGxC,kBAAkB+H,MAE9B,SAAEC,GAAaR,EACrB,OAAOQ,EAQX,yBAAyB5F,GAErB,MAAMxB,EAAWN,KAAKzC,QAAQ+C,SACxBqH,EAAa3H,KAAKzC,QAAQsC,MAC1B,IAAEiB,GAAQgB,SAGTA,EAAc,WACdA,EAAc,WACdA,EAAc,IAErBpG,EAAOiF,MAAM,8CAEb,MAAMpD,EAAU,CACZ+C,WACAsH,WAAY9G,EACZwG,UAAWK,EAAWE,UAAUJ,GAChCK,gBAAgB,IAAIlD,MAAOmD,cAC3BC,OAAQlG,GAENmG,QAAmBjI,KAAK6G,QAAQtE,cAAchF,GACpD7B,EAAOiF,MAAM,2CACb,MAAMuH,EAAc,CAChBD,aACAX,UAAWK,EAAWE,UAAUJ,GAChCU,WAAYR,EAAWS,kBAG3B,aAD+BpI,KAAK6G,QAAQwB,eAAeH,GAQ/D,6BACI,MAAMP,EAAa3H,KAAKzC,QAAQsC,KAC1ByI,QAAqBtI,KAAK6G,QAAQ0B,qBACpCvI,KAAKzC,QAAQkC,cACbkI,EAAWE,UAAUJ,IAEnB9E,EAAYoD,IAElB,aADiC/F,KAAK6G,QAAQ2B,iBAAiBF,EAAcX,EAAWE,UAAUJ,GAAIE,EAAWS,iBAAkBzF,GAOvI,4CACI,MAAM9F,QAAamD,KAAKuI,uBAClB9K,QAAaH,EAAU0C,KAAKqG,4BAA6B,CAC3DoC,OAAQ,OACRzK,QAAS,CACL,eAAgB,oBAEpBsD,KAAMxE,KAAKC,UAAUF,KAGzB,GAAmB,KAAfY,EAAK8D,OAGF,MAAmB,KAAf9D,EAAK8D,OACN,IAAIrE,MAAM,wCAEV,IAAIA,MAAMO,EAAKhB,OALrBuD,KAAKyG,uBAAwB,EAC7BzG,KAAKwG,aAAe/I,EAAKc,QAWjC,0BACI,GAAyB,IAArByB,KAAKwG,aACL9K,EAAOiF,MAAM,kGACPX,KAAK0I,0CACR,CACHhN,EAAOiF,MAAM,gEACb,MAAMgI,EAAqB,GAAG3I,KAAKqG,4CAA4CrG,KAAKwG,eAC9E/I,QAAaH,EAAUqL,EAAoB,CAC7CF,OAAQ,SAGZ,GAAmB,KAAfhL,EAAK8D,OACLvB,KAAKyG,uBAAwB,MAC1B,IAAmB,KAAfhJ,EAAK8D,OAIZ,MAAM,IAAIrE,MAAMO,EAAKhB,OAHrBf,EAAOiF,MAAM,qHACPX,KAAK0I,wCAYvB,yBAAyBjH,GACrB,aAAavB,EAAI0I,OAAOnH,EAAczB,KAAKzC,QAAQ4I,eAWvD,mBAAmB7E,GACf,MAAM,UAAEqB,EAAS,GAAEoE,GAAOzF,EAC1B,GAAItB,KAAK0G,6BACC1G,KAAK6I,qBACN7I,KAAKyG,uBAAuB,MAAM,IAAIvJ,MAAM,oCAGrD,MAAM8J,EAAQlK,KAAK0C,MAAMuH,GACnB+B,EAAU9B,EAA4B,qBAAE,GAAsB,kBAIpE,GAFAtL,EAAOiF,MAAM,sDAEDX,KAAKmH,mBAAmBH,EAAOrE,GAAa,MAAM,IAAIzF,MAAM,qCAIxE,MAAMkH,QAAoBlE,EAAI6I,KAAKD,EAAS9I,KAAKzC,QAAQ2I,UAAW,CAAE8C,UAAWhJ,KAAKzC,QAAQyI,gBACxFvE,QAAqBvB,EAAI6I,KAAKD,EAAS9I,KAAKzC,QAAQ4I,cAAe,CAAE6C,UAAWhJ,KAAKzC,QAAQ0I,0BAI7FxK,EAAWiK,IAAIoD,EAAQrB,GAAIhG,EAAczB,KAAKzC,QAAQ0I,mBAE5D,IAAI1B,EAAS/I,EAAYY,UAAUuG,GACnC,MAAMC,EAAS,CAAEwB,cAAa3C,gBAS9B,OARI8C,EAAOpI,YACPoI,EAAOpI,WAAWG,QAAQf,EAAmB,MAAO8C,GAAsB,EAAM,wBAAyBuE,KACzG2B,EAAS/I,EAAYyN,aAAatG,EAAW4B,EAAOpI,YAAY,EAAMyG,EAAOwB,YAAaxB,EAAOnB,cACjGjG,EAAYkB,aAAa6H,EAAOtI,WAEhCsI,EAAS/I,EAAYyN,aAAatG,EAAW,MAAM,EAAMC,EAAOwB,YAAaxB,EAAOnB,cAExF/F,EAAOiF,MAAM,uBACN,CACHqB,KAAM8G,KACHlG,GASX,cAAcnB,GACV,MAAMyH,QAAgBlJ,KAAKmJ,mBAAmB1H,GAK9C,SAF6BhG,EAAWxB,IAAIiP,EAAQzB,KAE9BhG,EAClB,MAAM,IAAIvE,MAAM,qDAGbgM,EAAa,WACbA,EAAa,IACpB,MAAM9E,QAAoBlE,EAAI6I,KAAKG,EAASlJ,KAAKzC,QAAQ2I,UAAW,CAAE8C,UAAWhJ,KAAKzC,QAAQyI,gBACxFoD,QAAiBlJ,EAAI6I,KAAKG,EAASlJ,KAAKzC,QAAQ4I,cAAe,CAAE6C,UAAWhJ,KAAKzC,QAAQ0I,oBAQ/F,aAFMxK,EAAWiK,IAAIwD,EAAQzB,GAAI2B,EAAUpJ,KAAKzC,QAAQ0I,mBAEjD,CACH7B,cACA3C,aAAc2H,GAQtB,aAAa3H,GACT,MAAMyH,QAAgBlJ,KAAKmJ,mBAAmB1H,SAExChG,EAAWgK,OAAOyD,EAAQzB,IAQpC,gBAAgB5F,GACZ,aAAa3B,EAAI0I,OAAO/G,EAAW7B,KAAKzC,QAAQ2I,WASpD,eAAelE,EAAMC,GAAmB,GACpC,IAAKjC,KAAKsG,YAAa,MAAM,IAAIpJ,MAAM,qCACvC,IAAK8C,KAAK2G,mBAAoB,MAAM,IAAIzJ,MAAM,uDAE9C,IAAK8E,EAAM,MAAM,IAAI9E,MAAM,iCAE3B,GAAI+E,EAAkB,CAClB,MAAM,IAAEnB,GAAQkB,EAEhB,IAAKlB,EAAK,MAAM,IAAI5D,MAAM,mDAG1B,aADmC8C,KAAKqJ,mBAAmBrH,GAI/D,MAAMK,QAAcnC,EAAI6I,KAAK/G,EAAMhC,KAAKzC,QAAQ2I,UAAW,CAAE8C,UAAWhJ,KAAKzC,QAAQyI,gBACrF,IAAIsD,EAAO,GAAGtJ,KAAKrC,UAAUqC,KAAK2G,4BAA4BtE,IAC1DkH,EAAe1D,EACnB0D,EAAeA,EAAaC,QAAQ,eAAgBxJ,KAAKzC,QAAQ0C,KAAKtG,MACtE4P,EAAeA,EAAaC,QAAQ,mBAAoBxH,EAAKrI,MAC7D4P,EAAeA,EAAaC,QAAQ,WAAYF,GAChD,MAAMG,EAAW3M,KAAKC,UAAU,CAC5BqG,OAAQ,aACRnG,IAAKqM,IAIHI,EAAmB,IAAKC,IAAI3J,KAAKzC,QAAQ6I,YAAaxC,OAEtDgG,EAAcC,UAAU,GADUH,EAAH,2DAC0ED,KAG/G,GAFAF,EAAeA,EAAaC,QAAQ,kBAAmBI,IAElD5H,EAAK8H,MAAO,MAAM,IAAI5M,MAAM,wDACd8C,KAAKsG,YAAYyD,UAAU/H,EAAK8H,MAAOP,EAAiBvJ,KAAKzC,QAAQ0C,KAAKtG,KAArB,6BACxE,OAAO,KASX,oBAAoB0I,EAAOC,GACvB,MAAMzF,QAAaqD,EAAI0I,OAAOvG,EAAOrC,KAAKzC,QAAQ2I,WAClDrJ,EAAKiE,IAAMwB,EAEX,aADmCtC,KAAKqJ,mBAAmBxM,GAI/D,YAAW,UAAE8F,IACT,IAAKA,EACD,MAAM,IAAIzF,MAAM,4BAEpB,IAAIqH,EAAS/I,EAAYY,UAAUuG,GACnC,IAAK4B,EACD,MAAM,IAAIrH,MAAM,qBAEpB,MAAM,gBAAEiH,EAAe,YAAEC,EAAW,aAAE3C,GAAiB8C,EACvD,IAAwB,IAApBJ,EACA,MAAM,IAAIjH,MAAM,gBAIpB,OADA1B,EAAYkB,aAAaiG,GAClB,CAAEyB,cAAa3C,mB,cCzW9BrJ,EAAOD,QAAUW,G,cCAjBV,EAAOD,QAAUY,G,cCoFjBX,EAAOD,QApFU,m8D,gBCAjB,MAAM6R,EAAa,EAAQ,KACrB,OAAEtO,GAAW,EAAQ,GAC3BtD,EAAOD,QAAU,MACf,aAAY,KAAEoO,EAAI,KAAE0D,EAAI,KAAEjI,EAAI,KAAEkI,EAAI,KAAEvQ,IACpCqG,KAAKuG,KAAOA,EACZvG,KAAKiK,KAAOA,EACZjK,KAAKkK,KAAOA,EACZlK,KAAKgC,KAAOA,EACZhC,KAAKrG,KAAOA,EAEZqG,KAAKmK,YAAcH,EAAWI,gBAAgB,CAC5C7D,KAAMvG,KAAKuG,KACX0D,KAAMjK,KAAKiK,KACXI,QAAQ,EACRC,KAAM,CACJtI,KAAMhC,KAAKgC,KACXkI,KAAMlK,KAAKkK,QAIflK,KAAKmK,YAAYvB,OAAO,CAAC2B,EAAKjM,KACxBiM,GAAKC,QAAQ/N,MAAM8N,GACvB7O,EAAOiF,MAAM,sCAIjB,gBAAgB8J,EAAIlM,EAASuK,GAO3B,aANmB9I,KAAKmK,YAAYO,SAAS,CAC3CC,KAAM,GAAG3K,KAAKrG,SAASqG,KAAKgC,QAC5ByI,KACA3B,QAAS,aAAeA,EACxB8B,KAAMrM,O,cC/BZnG,EAAOD,QAAUa,G,cCAjBZ,EAAOD,QAAUE,QAAQ,O,cCAzBD,EAAOD,QAAUE,QAAQ","file":"hypersign-auth-node-sdk.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"uuid\"), require(\"websocket\"), require(\"simple-node-logger\"), require(\"node-fetch\"), require(\"jsonwebtoken\"), require(\"hs-ssi-sdk\"), require(\"nodemailer\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([, , , , , , ], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Ae\"] = factory(require(\"uuid\"), require(\"websocket\"), require(\"simple-node-logger\"), require(\"node-fetch\"), require(\"jsonwebtoken\"), require(\"hs-ssi-sdk\"), require(\"nodemailer\"));\n\telse\n\t\troot[\"Ae\"] = factory(root[undefined], root[undefined], root[undefined], root[undefined], root[undefined], root[undefined], root[undefined]);\n})(global, function(__WEBPACK_EXTERNAL_MODULE__2__, __WEBPACK_EXTERNAL_MODULE__5__, __WEBPACK_EXTERNAL_MODULE__9__, __WEBPACK_EXTERNAL_MODULE__10__, __WEBPACK_EXTERNAL_MODULE__12__, __WEBPACK_EXTERNAL_MODULE__13__, __WEBPACK_EXTERNAL_MODULE__16__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","const ClientStore = require('./store/clientStore')\nconst TokenStore = require('./store/tokenStore')\nconst log = require(\"simple-node-logger\")\n\nconst { getFormatedMessage } =  require('./utils');\n\nconst clientStore = new ClientStore();\nconst tokenStore = new TokenStore();\n\n// LOGGING\nconst log_path = \"hypersign-auth.log\";\n\nconst logger = log.createSimpleLogger({\n    logFilePath: log_path,\n    timestampFormat: \"YYYY-MM-DD HH:mm:ss.SSS\"\n});\n\nlogger.setLevel(\"debug\");\n  \n\nclientStore.on('startTimer', (args) => {\n    try{\n        const { clientId, time } = args;\n        const { connection } = clientStore.getClient(clientId)\n        setTimeout(() => {\n            if(connection) connection.sendUTF(getFormatedMessage('reload', { clientId }));\n            clientStore.emit('deleteClient', { clientId });\n        }, time)        \n    }catch(e){\n        logger.error(e);\n    }\n})\n\nclientStore.on('deleteClient', (args) => {\n    try{\n        const { clientId } =  args;\n        clientStore.deleteClient(clientId);\n    }catch(e){\n        logger.error(e);\n    }\n})\n\nmodule.exports = {\n    clientStore,\n    tokenStore,\n    logger\n}","const fetch = require('node-fetch');\n\nexport function getFormatedMessage(op, data) {\n    return JSON.stringify({\n        op,\n        data\n    })\n}\n\nexport function sanetizeUrl(url) {\n    if (!url) throw new Error(\"Url is empty\");\n    if (url.substr(url.length - 1) == '/') {\n        return url.substr(0, url.length - 1)\n    } else return url;\n}\n\n\nexport async function fetchData(url, options) {\n    const resp = await fetch(url, options)\n    const json = await resp.json();\n    return json;\n}\n\nexport function checkSlash(baseUrl) {\n    if(!baseUrl) throw new Error(\"baseUrl is null or empty\");\n    baseUrl = baseUrl.trim();\n    if (!baseUrl.endsWith('/')) \n        return baseUrl + '/';\n    else\n        return baseUrl;\n}\n\nexport function extractToken(req) {\n    if (req.headers.authorization && req.headers.authorization.split(' ')[0] === 'Bearer') {\n        return req.headers.authorization.split(' ')[1];\n    }\n    return null;\n}\n\nexport function extractRfToken(req) {\n    // TODO:  need to find out what is the proper way of sending a refresh token, \n    // we are sending via \"refresh_token\": \"Bearer <Refresh token>\" header\n    if (req.headers.refreshtoken && req.headers.refreshtoken.split(' ')[0] === 'Bearer') {\n        return req.headers.refreshtoken.split(' ')[1];\n    }\n    return null;\n}\n\n\nexport function responseMessageFormat(success, message, data = {} ){\n    return { \n        hypersign: {\n            success,\n            message,\n            data\n        }\n    }\n} ","module.exports = __WEBPACK_EXTERNAL_MODULE__2__;","const HSWebsocket = require('./hsWebsocket');\nconst HypersignAuthService = require('./hsAuthService');\nconst fs = require('fs');\nconst path = require('path');\nconst { clientStore, logger } = require('./config');\nconst { extractToken, extractRfToken, responseMessageFormat } = require('./utils');\n\n\nconst HYPERSIGN_CONFIG_FILE = 'hypersign.json';\n\nmodule.exports = class HypersignAuth {\n\n    constructor(server, offlineSigner) {\n        ////\n        // Making it backward compatible\n        const hsFilePath = path.join(__dirname, '../../../', HYPERSIGN_CONFIG_FILE);\n        const hsFilePathDev = path.join(__dirname, '../', HYPERSIGN_CONFIG_FILE)\n        if (!fs.existsSync(hsFilePath) && !fs.existsSync(hsFilePathDev)) throw new Error(HYPERSIGN_CONFIG_FILE + ' file does not exist. Generate ' + HYPERSIGN_CONFIG_FILE + ' file from the developer dashboard; filePath = ' + hsFilePath);\n\n        const hypersignConfig = fs.readFileSync(HYPERSIGN_CONFIG_FILE);\n\n        const hsConfigJson = JSON.parse(hypersignConfig);\n\n        // TODO: we can delete this later. this is to make backward compatibility\n        hsConfigJson.appCredential.credentialSubject.authResourcePath = !hsConfigJson.appCredential.credentialSubject.authResourcePath ? \"hs/api/v2/auth\" : hsConfigJson.appCredential.credentialSubject.authResourcePath;\n        hsConfigJson.appCredential.credentialSubject.baseUrl = !hsConfigJson.appCredential.credentialSubject.baseUrl ? hsConfigJson.appCredential.credentialSubject.serviceEp : hsConfigJson.appCredential.credentialSubject.baseUrl;\n\n\n        if (hsConfigJson.keys == {}) throw new Error('Cryptographic keys is not set');\n        if (hsConfigJson.networkUrl == \"\") throw new Error('Network RPC Url is not set');\n        if (hsConfigJson.networkRestUrl == \"\") throw new Error('Network REST Url is not set');\n        if (hsConfigJson.appCredential == {}) throw new Error('App Credential is not set');\n        if (hsConfigJson.appCredential.credentialSubject == {}) throw new Error('Invalid credentialSubject');\n        if (!hsConfigJson.appCredential.credentialSubject.baseUrl) throw new Error(\"BaseUrl is not present in hypersign.json\");\n        if (!hsConfigJson.appCredential.credentialSubject.authResourcePath) throw new Error(\"AuthResourcePath is not present in hypersign.json\");\n\n        this.options = {\n            keys: {},\n            mail: {},\n            jwt: {},\n            rft: {},\n            appCredential: {},\n            offlineSigner\n        };\n        Object.assign(this.options.mail, hsConfigJson.mail);\n        Object.assign(this.options.keys, hsConfigJson.keys);\n        Object.assign(this.options.appCredential, hsConfigJson.appCredential);\n\n        this.options.networkUrl = hsConfigJson.networkUrl;\n        this.options.hidNodeRestURL = hsConfigJson.networkRestUrl;\n\n        this.options.schemaId = hsConfigJson.appCredential.credentialSubject.schemaId;\n        this.options.developerDashboardUrl = hsConfigJson.developerDashboardUrl ? hsConfigJson.developerDashboardUrl : 'https://ssi.hypermine.in/developer/';\n\n        if (!hsConfigJson.jwt) {\n            const jwtDefault = {\n                secret: 'BadsecretKey1@',\n                expiryTime: '900s' // epires in 15 mins\n            }\n            Object.assign(this.options.jwt, jwtDefault)\n            logger.debug('HS-AUTH:: JWT configuration not passed. Taking default configuration.. Secret = ' + jwtDefault.secret + ' ExpiryTime = ' + jwtDefault.expiryTime)\n        } else {\n            Object.assign(this.options.jwt, hsConfigJson.jwt)\n        }\n        if (!hsConfigJson.rft) {\n            const rftDefault = {\n                secret: 'BadsecretKey1@',\n                expiryTime: '900s' // epires in 15 mins\n            }\n            Object.assign(this.options.rft, rftDefault)\n            logger.debug('HS-AUTH:: Refresh Token configuration not passed. Taking default configuration.. Secret = ' + rftDefault.secret + ' ExpiryTime = ' + rftDefault.expiryTime)\n        } else {\n            Object.assign(this.options.rft, hsConfigJson.rft)\n        }\n\n        this.ws = new HSWebsocket(server,\n            hsConfigJson.appCredential.credentialSubject.baseUrl,\n            hsConfigJson.appCredential.credentialSubject.did,\n            hsConfigJson.appCredential.credentialSubject.name,\n            this.options.schemaId,\n            hsConfigJson.socketConnTimeOut,\n            hsConfigJson.appCredential.credentialSubject.authResourcePath);\n        this.ws.initiate();\n\n        this.options[\"isSubcriptionEnabled\"] = hsConfigJson[\"isSubcriptionEnabled\"] != undefined ? hsConfigJson[\"isSubcriptionEnabled\"] : true;\n\n    }\n\n    async init() {\n        this.middlewareService = new HypersignAuthService(this.options, this.options.appCredential.credentialSubject.baseUrl);\n        await this.middlewareService.init();\n    }\n\n    /**\n     * Authenticate a user by verifying verifiable presentation sent by a user via wallet\n     * @param { Request } req \n     * @param { Response } res \n     * @param { Next } next \n     */\n    async authenticate(req, res, next) {\n        try {\n            const data = await this.middlewareService.authenticate(req.body);\n            Object.assign(req.body, {...responseMessageFormat(true, \"Authenticated successfully\", {...data }) });\n            next();\n        } catch (e) {\n            logger.error(e)\n            res.status(401).send(responseMessageFormat(false, e.message));\n        }\n    }\n\n    /**\n     * Generates accessToken and refreshToken pair \n     * Ref: https://www.rfc-editor.org/rfc/rfc6749#section-6\n     * @param { Request } req \n     * @param { Response } res \n     * @param { Next } next  \n     */\n    async refresh(req, res, next) {\n        try {\n            const refreshToken = extractRfToken(req);\n            if (!refreshToken) throw new Error(\"Unauthorized: Refresh Token is not sent in header\")\n\n            const newtokens = await this.middlewareService.refresh(refreshToken);\n            Object.assign(req.body, {...responseMessageFormat(true, \"New pair of tokens\", {...newtokens }) });\n            next()\n        } catch (error) {\n            logger.error(error.message)\n            res.status(401).send(responseMessageFormat(false, e.message));\n        }\n    }\n\n    /**\n     * Logs out a user\n     * @param { Request } req \n     * @param { Response } res \n     * @param { Next } next  \n     */\n    async logout(req, res, next) {\n        try {\n            const refreshToken = extractRfToken(req);\n            if (!refreshToken) throw new Error(\"Unauthorized: Refresh Token is not sent in header\")\n\n            await this.middlewareService.logout(refreshToken);\n            // everthing is ok but there is no content\n            res.status(204).send();\n        } catch (error) {\n            logger.error(error.message)\n            res.status(401).send(responseMessageFormat(false, e.message));\n        }\n    }\n\n    /**\n     * Verifies accessToken and returns payload\n     * @param { Request } req \n     * @param { Response } res \n     * @param { Next } next  \n     */\n    async authorize(req, res, next) {\n        try {\n            const authToken = extractToken(req);\n            if (!authToken) throw new Error('Authorization token is not passed in the header')\n            const userData = await this.middlewareService.authorize(authToken)\n            Object.assign(req.body, {...responseMessageFormat(true, \"Authorized successfully\", {...userData }) });\n            next();\n        } catch (e) {\n            logger.error(e)\n            res.status(403).send(responseMessageFormat(false, e.message));\n        }\n    }\n\n\n    /**\n     * Registers a new user and sends email\n     * @param { Request } req \n     * @param { Response } res \n     * @param { Next } next \n     */\n    async register(req, res, next) {\n        try {\n            const { user, isThridPartyAuth } = req.body;\n            if (!user) {\n                return res.status(400).send(responseMessageFormat(false, 'user object is not passed in the body'));\n            }\n            const vc = await this.middlewareService.register(user, isThridPartyAuth ? isThridPartyAuth : false);\n            if (vc) {\n                Object.assign(req.body, {...responseMessageFormat(true, \"Verifiable Credential\", {...vc }) });\n            }\n            next();\n        } catch (e) {\n            logger.error(e)\n            res.status(500).send(responseMessageFormat(false, e.message));\n        }\n    }\n\n    /**\n     * Verifies the verifiable credential  JWT and issues auth verifiable credential\n     * @param { Request } req \n     * @param { Response } res \n     * @param { Next } next \n     */\n    async issueCredential(req, res, next) {\n        try {\n            const authToken = req.query.token;\n            const userDid = req.query.did\n            if (!authToken) {\n                return res.status(400).send(responseMessageFormat(false, 'token is not passed in the in query'));\n            }\n\n            if (!userDid) {\n                return res.status(400).send(responseMessageFormat(false, 'did is not passed in the in query'));\n            }\n\n            const vc = await this.middlewareService.getCredential(authToken, userDid);\n            Object.assign(req.body, {...responseMessageFormat(true, \"Verifiable Credential\", {...vc }) });\n            next();\n        } catch (e) {\n            logger.error(e)\n            res.status(500).send(responseMessageFormat(false, e.message));\n        }\n    }\n\n    /**\n     * Generates QR data (with challenge) in case the service provider does not want to uee websocket and go with polling\n     * @param { Request } req \n     * @param { Response } res \n     * @param { Next } next  \n     */\n    async challenge(req, res, next) {\n        try {\n            const clientId = clientStore.addClient(null);\n            clientStore.emit('startTimer', { clientId: clientId, time: 120000 });\n            const QRData = this.ws.getQRData(clientId);\n            Object.assign(req.body, {...responseMessageFormat(true, \"New session data\", QRData) })\n            next();\n        } catch (e) {\n            res.status(400).send(responseMessageFormat(false, e.message));\n        }\n    }\n\n    /**\n     * Call this to check if a user has authenticated or not via wallet\n     * @param { Request } req \n     * @param { Response } res \n     * @param { Next } next  \n     */\n    async poll(req, res, next) {\n        try {\n            let challenge;\n            if (req.query && req.query.challenge) {\n                challenge = req.query.challenge;\n            } else if (req.body && req.body.challenge) {\n                challenge = req.body.challenge;\n            }\n            if (!challenge) {\n                return res.status(400).send(responseMessageFormat(false, \"Challenge is not passed in the request body or query parameter\"))\n            }\n            const tokens = await this.middlewareService.poll({ challenge });\n            Object.assign(req.body, {...responseMessageFormat(true, 'User is authenticated', {...tokens }) })\n            next();\n        } catch (e) {\n            res.status(401).send(responseMessageFormat(false, e.message));\n        }\n    }\n\n}","const WebSocket = require('websocket')\nconst { clientStore, logger } = require('./config')\nconst { getFormatedMessage, checkSlash } =  require('./utils');\n\n\n\nmodule.exports = class HSWebsocket {\n    constructor(server, baseUrl, appDid, appName, schemaId, socketConnectionTimeOut = 60000, authResourcePath) {\n        if (!server) throw new Error('Http server is required.')\n        if (!baseUrl) throw new Error('Server baseUrl is required.')\n        this.server = server;\n        this.baseUrl = checkSlash(baseUrl);\n        this.appDid = appDid;\n        this.appName = appName;\n        this.schemaId = schemaId;\n        this.socketConnectionTimeOut = socketConnectionTimeOut;\n        this.authResourcePath = authResourcePath.startsWith(\"/\") ? authResourcePath.substring(1): authResourcePath ; \n    }\n\n    getQRData(challenge){\n        const JSONData = {\n            QRType: 'REQUEST_CRED',\n            serviceEndpoint:  this.baseUrl + this.authResourcePath,\n            schemaId: this.schemaId,\n            appDid: this.appDid,\n            appName: this.appName,\n            challenge\n        }\n\n        return JSONData;\n    }\n\n    initiate() {\n        const wss = new WebSocket.server({\n            httpServer: this.server, // Tieing websocket to HTTP server\n            autoAcceptConnections: false\n        })\n        const that = this;\n        wss.on('request', (request) => {\n            const connection = request.accept(null, request.origin)\n            logger.debug(`HS-AUTH:: Client connected`)\n            \n            const clientId = clientStore.addClient(connection);\n            clientStore.emit('startTimer', {clientId: clientId, time: this.socketConnectionTimeOut});\n            \n            const JSONData = that.getQRData(clientId);\n\n            connection.sendUTF(getFormatedMessage('init', JSONData));\n            connection.on('message', (m) => {\n\n            })\n            connection.on('close', (conn, clientId) => {\n                if(conn == 4001 && clientId) {\n                    clientStore.emit('deleteClient', { clientId });\n                }\n                logger.debug(`HS-AUTH:: Client disconnected`)                \n            })\n        })\n    }\n}","module.exports = __WEBPACK_EXTERNAL_MODULE__5__;","const { v4: uuidv4 } = require('uuid');\nconst EventEmitter = require('events');\n\nclass Client {\n  constructor(connection) {\n    this.clientId = uuidv4();\n    this.connection = connection;\n    this.isAuthenticated = false;\n    this.accessToken = null;\n    this.refreshToken = null;\n  }\n}\n\nmodule.exports = class ClientStore extends EventEmitter {\n  constructor() {\n    super();\n    this.clients = {}; //in-mem store\n  }\n\n  addClient(connection) {\n    // if (!connection) throw new Error('Connection is null')\n    const client = new Client(connection);\n    this.clients[client.clientId] = client;\n    return client.clientId;\n  }\n\n  getClient(clientId) {\n    if (!this.clients[clientId]) throw new Error('Invalid challenge');\n    return this.clients[clientId];\n  }\n\n  updateClient(clientId, connection, isAuthenticated, accessToken, refreshToken) {\n    if (!this.clients[clientId]) throw new Error('Invalid challenge');\n    let updatedClient = this.clients[clientId];\n    if (connection) updatedClient['connection'] = connection;\n    if (isAuthenticated) updatedClient['isAuthenticated'] = isAuthenticated;\n    if (accessToken) updatedClient['accessToken'] = accessToken;\n    if (refreshToken) updatedClient['refreshToken'] = refreshToken;\n    this.clients[clientId] = updatedClient;\n    return updatedClient;\n  }\n\n  deleteClient(clientId) {\n    //if (!this.clients[clientId]) throw new Error('Client does not exist')\n    delete this.clients[clientId];\n    return Object.keys(this.clients).length;\n  }\n\n  getAllClientIds() {\n    return Object.keys(this.clients);\n  }\n};\n","module.exports = require(\"events\");","module.exports = class TokenStore {\n  constructor() {\n    this.store = new Map();\n  }\n\n  // seconds to date\n  toDateTime(secs) {\n    const t = new Date(); // Epoch\n    t.setSeconds(t.getSeconds() + secs);\n    return t;\n  }\n\n  // the reason I had to use this becuase When delay is larger than 2147483647 the delay will be set to 1 since\n  // setTimeout using a 32 bit INT to store the delay so the max value allowed would be 2147483647\n  // Ref: https://stackoverflow.com/questions/3468607/why-does-settimeout-break-for-large-millisecond-delay-values\n  triggerDelete(date, func) {\n    const now = new Date().getTime();\n    const then = date.getTime();\n    const diff = Math.max(then - now, 0);\n    if (diff > 0x7fffffff) {\n      //setTimeout limit is MAX_INT32=(2^31-1)\n      setTimeout(function () {\n        this.triggerDelete(date, func);\n      }, 0x7fffffff);\n    } else {\n      setTimeout(func, diff);\n    }\n  }\n\n  // by default ref token never expires in 30s\n  set(key, value, expiryTime = 30) {\n    this.triggerDelete(this.toDateTime(expiryTime), () => {\n      this.delete(key);\n    });\n    return this.store.set(key, value);\n  }\n\n  get(key) {\n    return this.store.get(key);\n  }\n  has(key) {\n    return this.store.has(key);\n  }\n  delete(key) {\n    return this.store.delete(key);\n  }\n};\n","module.exports = __WEBPACK_EXTERNAL_MODULE__9__;","module.exports = __WEBPACK_EXTERNAL_MODULE__10__;","const jwt = require('jsonwebtoken');\nconst HypersignSsiSDK = require('hs-ssi-sdk');\nconst regMailTemplate = require('./mail/mail.template');\nconst MailService = require('./mail/mail.service');\nconst { clientStore, tokenStore, logger } = require('./config');\nconst { v4: uuid4 } = require('uuid');\nconst { sanetizeUrl, getFormatedMessage, fetchData, responseMessageFormat } = require('./utils');\n\n\nmodule.exports = class HypersignAuthService {\n\n    constructor(options = {}, baseUrl) {\n        this.options = {};\n        this.options.jwtExpiryTime = options && options.jwt.expiryTime ? options.jwt.expiryTime : 240000;\n        this.options.rftokenExpiryTime = options && options.rft.expiryTime ? options.rft.expiryTime : 1000;\n        this.options.jwtSecret = options && options.jwt.secret ? options.jwt.secret : 'secretKey';\n        this.options.rftokenSecret = options && options.rft.secret ? options.rft.secret : '8e5507e12da789f3c3bd640711378201d658657999384061bb';\n        this.options.hidNodeURL = options && options.networkUrl ? options.networkUrl : \"http://localhost:26657\"\n        this.options.hidNodeRestURL = options && options.networkRestUrl ? options.networkRestUrl : \"http://localhost:1317\"\n        this.options.mail = options && options.mail ? options.mail : mail;\n\n        if (!options.offlineSigner) {\n            throw new Error('OfflineSigner is required for initilizing Hypersign Auth Service')\n        }\n        this.options.offlineSigner = options.offlineSigner\n\n        this.baseUrl = baseUrl;\n        this.baseUrl = sanetizeUrl(this.baseUrl);\n        this.options.hidNodeURL = sanetizeUrl(this.options.hidNodeURL)\n        this.options.hidNodeRestURL = sanetizeUrl(this.options.hidNodeRestURL)\n\n        this.options.keys = options.keys;\n\n        // const hsSdk = new hsSdk({ nodeUrl: this.options.hidNodeURL });\n\n\n        this.options.schemaId = options.schemaId;\n\n        this.options.mail = options.mail;\n\n\n        this.options.appCredential = options.appCredential;\n        this.developerDashboardVerifyApi = `${ sanetizeUrl(options.developerDashboardUrl)}/hs/api/v2/subscription/verify`;\n\n        this.mailService = this.options.mail && this.options.mail.host != \"\" ? new MailService({...this.options.mail }) : null;\n\n\n        this.apiAuthToken = \"\";\n        this.isSubscriptionSuccess = false;\n        this.isSubcriptionEnabled = options.isSubcriptionEnabled;\n\n        this.verifyResourcePath = this.options.appCredential.credentialSubject.verifyResourcePath != \"\" ?\n            (this.options.appCredential.credentialSubject.verifyResourcePath.startsWith(\"/\") ? this.options.appCredential.credentialSubject.verifyResourcePath : \"/\" + this.options.appCredential.verifyResourcePath) :\n            \"/hs/api/v2/credential\";\n    }\n\n\n    async init() {\n        const hsSdk = new HypersignSsiSDK(this.options.offlineSigner, this.options.hidNodeURL, this.options.hidNodeRestURL);\n        await hsSdk.init();\n        this.hsSdkVC = hsSdk.vc;\n        this.hsSDKVP = hsSdk.vp;\n    }\n\n    /**\n     * Verifies VP\n     * @param { Object } vpObj  // verifiable presentation\n     * @param { String } challenge  // challenge\n     * @returns boolean \n     */\n    async verifyPresentation(vpObj, challenge) {\n        if (!vpObj) throw new Error('presentation is null')\n        if (!challenge) throw new Error('challenge is null')\n        const vc = vpObj.verifiableCredential[0];\n        const result = await this.hsSDKVP.verifyPresentation({\n            signedPresentation: vpObj,\n            challenge,\n            domain: \"https://localhos:20202\", //TODO:  need to remove this hardcoding\n            issuerDid: vc.issuer,\n            holderDid: vc.credentialSubject.id,\n        })\n        const { verified } = result;\n        return verified;\n    }\n\n    /**\n     * Generates verfiable credentials based on userdata \n     * @param { Object } userData \n     * @returns signed VC\n     */\n    async generateCredential(userData) {\n        // const schemaUrl = this.options.hidNodeURL + '/api/v1/schema/' + this.options.schemaId;\n        const schemaId = this.options.schemaId;\n        const issuerKeys = this.options.keys;\n        const { did } = userData;\n\n        // removing unwanted fields since they got added by JWT\n        delete userData['iat'];\n        delete userData['exp'];\n        delete userData['did'];\n\n        logger.debug(\"HS-AUTH:: Credential is being generated...\")\n\n        const options = {\n            schemaId,\n            subjectDid: did,\n            issuerDid: issuerKeys.publicKey.id,\n            expirationDate: new Date().toISOString(),\n            fields: userData\n        }\n        const credential = await this.hsSdkVC.getCredential(options)\n        logger.debug(\"HS-AUTH:: Credential is being signed...\")\n        const signOptions = {\n            credential,\n            issuerDid: issuerKeys.publicKey.id,\n            privateKey: issuerKeys.privateKeyBase58\n        }\n        const signedCredential = await this.hsSdkVC.signCredential(signOptions)\n        return signedCredential\n    }\n\n    /**\n     * Generates verifiable presentation\n     * @returns signed VP\n     */\n    async generatePresentation() {\n        const issuerKeys = this.options.keys;\n        const presentation = await this.hsSdkVC.generatePresentation(\n            this.options.appCredential,\n            issuerKeys.publicKey.id\n        );\n        const challenge = uuid4();\n        const signedPresentation = await this.hsSdkVC.signPresentation(presentation, issuerKeys.publicKey.id, issuerKeys.privateKeyBase58, challenge)\n        return signedPresentation\n    }\n\n    /**\n     * Calls subscription api to check for plan and subscription\n     */\n    async callSubscriptionAPIwithPresentation() {\n        const data = await this.generatePresentation();\n        const json = await fetchData(this.developerDashboardVerifyApi, {\n            method: 'POST',\n            headers: {\n                \"Content-Type\": \"application/json\",\n            },\n            body: JSON.stringify(data)\n        })\n\n        if (json.status == 200) {\n            this.isSubscriptionSuccess = true;\n            this.apiAuthToken = json.message;\n        } else if (json.status == 401) {\n            throw new Error('Unauthorized subscription API access');\n        } else {\n            throw new Error(json.error);\n        }\n    }\n\n    /**\n     * Check for subscription\n     */\n    async checkSubscription() {\n        if (this.apiAuthToken == \"\") {\n            logger.debug('HS-AUTH:: No API Authorization token found, authenticating using verifiable presentation');\n            await this.callSubscriptionAPIwithPresentation();\n        } else {\n            logger.debug('HS-AUTH:: Found API Authorization token, trying to authorize');\n            const developerPortalAPI = `${this.developerDashboardVerifyApi}?apiAuthToken=${this.apiAuthToken}`;\n            const json = await fetchData(developerPortalAPI, {\n                method: 'POST',\n            });\n\n            if (json.status == 200) {\n                this.isSubscriptionSuccess = true;\n            } else if (json.status == 403) {\n                logger.debug('HS-AUTH:: API Authorization token has expired. Trying to authentication again using verifiable presentation');\n                await this.callSubscriptionAPIwithPresentation();\n            } else {\n                throw new Error(json.error);\n            }\n        }\n    }\n\n    /**\n     * Verifies refreshtoken JWT\n     * @param { String } refreshToken \n     * @returns payload\n     */\n    async verifyRefreshToken(refreshToken) {\n        return await jwt.verify(refreshToken, this.options.rftokenSecret)\n    }\n\n    // Public methods\n    /////////////////\n\n    /**\n     * Authenticates user's credentials\n     * @param { object } body \n     * @returns accessToken and refreshToken\n     */\n    async authenticate(body) {\n        const { challenge, vp } = body;\n        if (this.isSubcriptionEnabled) {\n            await this.checkSubscription();\n            if (!this.isSubscriptionSuccess) throw new Error('Subscription check unsuccessfull')\n        }\n\n        const vpObj = JSON.parse(vp);\n        const subject = vpObj['verifiableCredential'][0]['credentialSubject'];\n\n        logger.debug(\"HS-AUTH:: Presentation is being verified...\")\n\n        if (!(await this.verifyPresentation(vpObj, challenge))) throw new Error('Could not verify the presentation')\n\n        // TODO:  need to find out if we are missing any imp parameter in the options.\n        // what is the proper way to JWT sign \n        const accessToken = await jwt.sign(subject, this.options.jwtSecret, { expiresIn: this.options.jwtExpiryTime });\n        const refreshToken = await jwt.sign(subject, this.options.rftokenSecret, { expiresIn: this.options.rftokenExpiryTime })\n\n        // TODO:  once we use redis , we can set the expiration time = this.options.rftokenExpiryTime also\n        // but for in-mem, let;s keep it simple\n        await tokenStore.set(subject.id, refreshToken, this.options.rftokenExpiryTime)\n\n        let client = clientStore.getClient(challenge)\n        const tokens = { accessToken, refreshToken }\n        if (client.connection) {\n            client.connection.sendUTF(getFormatedMessage('end', responseMessageFormat(true, 'User is authenticated', tokens)))\n            client = clientStore.updateClient(challenge, client.connection, true, tokens.accessToken, tokens.refreshToken);\n            clientStore.deleteClient(client.clientId);\n        } else {\n            client = clientStore.updateClient(challenge, null, true, tokens.accessToken, tokens.refreshToken);\n        }\n        logger.debug(\"HS-AUTH:: Finished.\")\n        return {\n            user: subject,\n            ...tokens\n        }\n    }\n\n    /**\n     * Verifies old refresh token and generates a new pair\n     * @param { string } refreshToken \n     * @returns accessToken and refreshToken\n     */\n    async refresh(refreshToken) {\n        const payload = await this.verifyRefreshToken(refreshToken)\n\n        // TODO: we need to check if this refresh token was present in the store.\n        const refTokenStored = await tokenStore.get(payload.id)\n\n        if (refTokenStored != refreshToken) {\n            throw new Error(\"Unauthorized: Invalid ref token or expired\")\n        }\n\n        delete payload[\"exp\"]\n        delete payload[\"iat\"]\n        const accessToken = await jwt.sign(payload, this.options.jwtSecret, { expiresIn: this.options.jwtExpiryTime })\n        const refToken = await jwt.sign(payload, this.options.rftokenSecret, { expiresIn: this.options.rftokenExpiryTime })\n\n        // TODO::  store the ref token using key value , user did as key\n        // Store the tokens in key val\n        // TODO:  once we use redis , we can set the expiration time = this.options.rftokenExpiryTime also\n        // but for in-mem, let;s keep it simple\n        await tokenStore.set(payload.id, refToken, this.options.rftokenExpiryTime) // the expirey time is in second\n\n        return {\n            accessToken,\n            refreshToken: refToken\n        }\n    }\n\n    /**\n     * Deletes refresh token for that user\n     * @param { string } refreshToken \n     */\n    async logout(refreshToken) {\n        const payload = await this.verifyRefreshToken(refreshToken)\n            // TODO: delete on logout\n        await tokenStore.delete(payload.id)\n    }\n\n    /**\n     * Verifies JWT accessToken\n     * @param { string } authToken \n     * @returns payload\n     */\n    async authorize(authToken) {\n        return await jwt.verify(authToken, this.options.jwtSecret)\n    }\n\n    /**\n     * Geneartes verifiable credential JWT and sends email\n     * @param { object } user \n     * @param { boolean } isThridPartyAuth \n     * @returns null\n     */\n    async register(user, isThridPartyAuth = false) {\n        if (!this.mailService) throw new Error(\"Mail configuration is not defined\");\n        if (!this.verifyResourcePath) throw new Error(\"VerifyResourcePath is not set in configuration file\")\n\n        if (!user) throw new Error(\"User object is null or empty.\")\n\n        if (isThridPartyAuth) {\n            const { did } = user;\n\n            if (!did) throw new Error(\"Did must be passed with thirdparty auth request\");\n\n            const verifiableCredential = await this.generateCredential(user);\n            return verifiableCredential;\n        }\n\n        const token = await jwt.sign(user, this.options.jwtSecret, { expiresIn: this.options.jwtExpiryTime })\n        let link = `${this.baseUrl}${this.verifyResourcePath}?token=${token}`;\n        let mailTemplate = regMailTemplate;\n        mailTemplate = mailTemplate.replace(/@@APPNAME@@/g, this.options.mail.name);\n        mailTemplate = mailTemplate.replace('@@RECEIVERNAME@@', user.name);\n        mailTemplate = mailTemplate.replace('@@LINK@@', link);\n        const JSONdata = JSON.stringify({\n            QRType: 'ISSUE_CRED',\n            url: link\n        });\n\n        // TODO:  need to remove this hardcoded url\n        const authServerOrigin = (new URL(this.options.hidNodeURL)).origin;\n        const authenticationServerEndPoint = `${authServerOrigin}/hsauth`\n        const deepLinkUrl = encodeURI(`${authenticationServerEndPoint}/deeplink.html?deeplink=hypersign:deeplink?url=${JSONdata}`);\n        mailTemplate = mailTemplate.replace(\"@@DEEPLINKURL@@\", deepLinkUrl);\n\n        if (!user.email) throw new Error(\"No email is passed. Email is required property\");\n        const info = await this.mailService.sendEmail(user.email, mailTemplate, `${this.options.mail.name} Auth Credential Issuance`);\n        return null;\n    }\n\n    /**\n     * Verifies VC JWT and Geneartes verifiable credential\n     * @param { string } token \n     * @param { string } userDid \n     * @returns verifiable credential\n     */\n    async getCredential(token, userDid) {\n        const data = await jwt.verify(token, this.options.jwtSecret)\n        data.did = userDid;\n        const verifiableCredential = await this.generateCredential(data);\n        return verifiableCredential\n    }\n\n    async poll({ challenge }) {\n        if (!challenge) {\n            throw new Error(\"Challenge must be passed\");\n        }\n        let client = clientStore.getClient(challenge);\n        if (!client) {\n            throw new Error(\"Invalid challenge\");\n        }\n        const { isAuthenticated, accessToken, refreshToken } = client;\n        if (isAuthenticated === false) {\n            throw new Error(\"Unauthorized\");\n        }\n\n        clientStore.deleteClient(challenge);\n        return { accessToken, refreshToken };\n    }\n}","module.exports = __WEBPACK_EXTERNAL_MODULE__12__;","module.exports = __WEBPACK_EXTERNAL_MODULE__13__;","const template = `\n<html>\n\n<head>\n    <style>\n        .colored {\n            color: blue;\n        }\n\n        #body {\n            background-color: #80808021\n            font-size: 18px;\n            border: 1px solid #80808021;\n            padding:20px;\n        }\n\n        .center{\n            margin: auto;\n            width: 50%;\n        }\n\n        .mobile {\n            display: none;\n        }\n        .web {\n            display:block;\n        }\n        .button {\n            background-color: #272831;\n            /* blakish */\n            border: none;\n            color: #f1f1f1;\n            border-radius: 8px;\n            padding: 20px;\n            text-align: center;\n            text-decoration: none;\n            font-size: 16px;\n            cursor: pointer;\n            width:30%;\n        }\n\n        @media only screen and (max-device-width : 640px) {\n\n            /* Styles */\n            .mobile {\n                display: block;\n            }\n            .web {\n                display:none;\n            }\n        }\n\n        @media only screen and (max-device-width: 768px) {\n\n            /* Styles */\n            .mobile {\n                display: block;\n            }\n            .web {\n                display:none;\n            }\n        }\n    </style>\n</head>\n\n<body>\n    <div id='body' class=\"center\">\n        <p class='center'><h3>Hi @@RECEIVERNAME@@,</h3></p>\n        <p class='center' style='width:100%'><h5>Welcome to @@APPNAME@@!</h5></p>\n        <p class='colored'>\n            @@APPNAME@@ credential is being issued to you. \n        </p>\n        <p class='colored'>Tap 'Get Credential' button (or link) to receieve the credential in your Hypersign Identity Wallet.</p>\n        <br/>\n        <p><a href='@@DEEPLINKURL@@' class=\"button\">Get credential</a></p>\n        <br/>\n        <br/>\n        <p>Thanks & Regards, <br />Team @@APPNAME@@!</p>\n        <p></p>\n    </div>\n</body>\n\n</html>\n`;\nmodule.exports = template;\n","const nodemailer = require('nodemailer');\nconst { logger } = require('../config');\nmodule.exports = class MailService {\n  constructor({ host, port, user, pass, name }) {\n    this.host = host;\n    this.port = port;\n    this.pass = pass;\n    this.user = user;\n    this.name = name;\n\n    this.transporter = nodemailer.createTransport({\n      host: this.host,\n      port: this.port,\n      secure: true, // true for 465, false for other ports. TODO: find better way to work with it\n      auth: {\n        user: this.user,\n        pass: this.pass,\n      },\n    });\n\n    this.transporter.verify((err, success) => {\n      if (err) console.error(err);\n      logger.debug('HS-AUTH:: Your config is correct');\n    });\n  }\n\n  async sendEmail(to, message, subject) {\n    const info = await this.transporter.sendMail({\n      from: `${this.name} <${this.user}>`,\n      to,\n      subject: 'No reply: ' + subject,\n      html: message,\n    });\n    return info;\n  }\n};\n","module.exports = __WEBPACK_EXTERNAL_MODULE__16__;","module.exports = require(\"fs\");","module.exports = require(\"path\");"],"sourceRoot":""}