{"version":3,"sources":["webpack://Ae/webpack/universalModuleDefinition","webpack://Ae/webpack/bootstrap","webpack://Ae/./src/config.js","webpack://Ae/./src/utils.js","webpack://Ae/external {\"commonjs\":\"uuid\",\"commonjs2\":\"uuid\"}","webpack://Ae/./src/index.js","webpack://Ae/./src/hsWebsocket.js","webpack://Ae/external {\"commonjs\":\"websocket\",\"commonjs2\":\"websocket\"}","webpack://Ae/./src/store/clientStore.js","webpack://Ae/external \"events\"","webpack://Ae/./src/store/tokenStore.js","webpack://Ae/external {\"commonjs\":\"simple-node-logger\",\"commonjs2\":\"simple-node-logger\"}","webpack://Ae/external {\"commonjs\":\"node-fetch\",\"commonjs2\":\"node-fetch\"}","webpack://Ae/./src/hsAuthService.js","webpack://Ae/external {\"commonjs\":\"jsonwebtoken\",\"commonjs2\":\"jsonwebtoken\"}","webpack://Ae/external {\"commonjs\":\"hs-ssi-sdk\",\"commonjs2\":\"hs-ssi-sdk\"}","webpack://Ae/./src/mail/mail.template.js","webpack://Ae/./src/mail/mail.service.js","webpack://Ae/external {\"commonjs\":\"nodemailer\",\"commonjs2\":\"nodemailer\"}","webpack://Ae/external \"fs\"","webpack://Ae/external \"path\""],"names":["root","factory","exports","module","require","define","amd","undefined","global","__WEBPACK_EXTERNAL_MODULE__2__","__WEBPACK_EXTERNAL_MODULE__5__","__WEBPACK_EXTERNAL_MODULE__9__","__WEBPACK_EXTERNAL_MODULE__10__","__WEBPACK_EXTERNAL_MODULE__12__","__WEBPACK_EXTERNAL_MODULE__13__","__WEBPACK_EXTERNAL_MODULE__16__","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","ClientStore","TokenStore","log","getFormatedMessage","clientStore","tokenStore","logger","createSimpleLogger","logFilePath","timestampFormat","setLevel","on","args","clientId","time","connection","getClient","setTimeout","sendUTF","emit","e","error","deleteClient","fetch","op","data","JSON","stringify","sanetizeUrl","url","Error","substr","length","async","fetchData","options","resp","json","checkSlash","baseUrl","trim","endsWith","extractToken","req","headers","authorization","split","extractRfToken","refreshtoken","responseMessageFormat","success","message","hypersign","isDate","date","Date","isNaN","HSWebsocket","HypersignAuthService","fs","path","server","offlineSigner","hsFilePath","join","__dirname","hsFilePathDev","existsSync","hypersignConfig","readFileSync","hsConfigJson","parse","appCredential","credentialSubject","authResourcePath","serviceEp","keys","networkUrl","networkRestUrl","namespace","debug","this","mail","jwt","rft","assign","hidNodeRestURL","schemaId","developerDashboardUrl","jwtDefault","secret","expiryTime","rftDefault","ws","did","socketConnTimeOut","initiate","middlewareService","init","res","next","authenticate","body","status","send","refreshToken","newtokens","refresh","logout","authToken","userData","authorize","user","isThridPartyAuth","expirationDate","vc","register","query","token","userDid","getCredential","addClient","QRData","getQRData","challenge","tokens","poll","WebSocket","appDid","appName","socketConnectionTimeOut","startsWith","substring","QRType","serviceEndpoint","wss","httpServer","autoAcceptConnections","that","request","accept","origin","JSONData","conn","v4","uuidv4","EventEmitter","Client","isAuthenticated","accessToken","super","clients","client","updatedClient","store","Map","secs","setSeconds","getSeconds","func","now","getTime","then","diff","Math","max","triggerDelete","toDateTime","delete","set","has","HypersignSSISdk","regMailTemplate","MailService","uuid4","jwtExpiryTime","rftokenExpiryTime","jwtSecret","rftokenSecret","hidNodeURL","developerDashboardVerifyApi","mailService","host","apiAuthToken","isSubscriptionSuccess","isSubcriptionEnabled","verifyResourcePath","hsSdk","nodeRpcEndpoint","nodeRestEndpoint","hsSdkVC","hsSDKVP","vp","vpObj","holderDidDocSigned","console","verifiableCredential","holderDidDocSignedtemp","signedPresentation","domain","issuerDid","issuer","holderVerificationMethodId","proof","verificationMethod","issuerVerificationMethodId","holderDid","id","result","verify","verified","didDoc","issuerKeys","subjectDidDocSigned","publicKey","fields","subjectDid","credential","generate","verificationMethodId","signOptions","privateKeyMultibase","privateKeyBase58","registerCredential","signedCredential","issue","txn_message","generateRegisterCredentialStatusTxnMessage","credentialStatus","credentialStatusProof","txn","presentation","generatePresentation","sign","method","callSubscriptionAPIwithPresentation","developerPortalAPI","checkSubscription","subject","verifyPresentation","expiresIn","updateClient","payload","verifyRefreshToken","refToken","generateCredential","link","mailTemplate","replace","JSONdata","authServerOrigin","URL","deepLinkUrl","encodeURI","email","sendEmail","nodemailer","port","pass","transporter","createTransport","secure","auth","err","to","sendMail","from","html"],"mappings":"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","file":"hypersign-auth-node-sdk.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"uuid\"), require(\"websocket\"), require(\"simple-node-logger\"), require(\"node-fetch\"), require(\"jsonwebtoken\"), require(\"hs-ssi-sdk\"), require(\"nodemailer\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([, , , , , , ], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Ae\"] = factory(require(\"uuid\"), require(\"websocket\"), require(\"simple-node-logger\"), require(\"node-fetch\"), require(\"jsonwebtoken\"), require(\"hs-ssi-sdk\"), require(\"nodemailer\"));\n\telse\n\t\troot[\"Ae\"] = factory(root[undefined], root[undefined], root[undefined], root[undefined], root[undefined], root[undefined], root[undefined]);\n})(global, function(__WEBPACK_EXTERNAL_MODULE__2__, __WEBPACK_EXTERNAL_MODULE__5__, __WEBPACK_EXTERNAL_MODULE__9__, __WEBPACK_EXTERNAL_MODULE__10__, __WEBPACK_EXTERNAL_MODULE__12__, __WEBPACK_EXTERNAL_MODULE__13__, __WEBPACK_EXTERNAL_MODULE__16__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","const ClientStore = require('./store/clientStore')\nconst TokenStore = require('./store/tokenStore')\nconst log = require(\"simple-node-logger\")\n\nconst { getFormatedMessage } =  require('./utils');\n\nconst clientStore = new ClientStore();\nconst tokenStore = new TokenStore();\n\n// LOGGING\nconst log_path = \"hypersign-auth.log\";\n\nconst logger = log.createSimpleLogger({\n    logFilePath: log_path,\n    timestampFormat: \"YYYY-MM-DD HH:mm:ss.SSS\"\n});\n\nlogger.setLevel(\"debug\");\n  \n\nclientStore.on('startTimer', (args) => {\n    try{\n        const { clientId, time } = args;\n        const { connection } = clientStore.getClient(clientId)\n        setTimeout(() => {\n            if(connection) connection.sendUTF(getFormatedMessage('reload', { clientId }));\n            clientStore.emit('deleteClient', { clientId });\n        }, time)        \n    }catch(e){\n        logger.error(e);\n    }\n})\n\nclientStore.on('deleteClient', (args) => {\n    try{\n        const { clientId } =  args;\n        clientStore.deleteClient(clientId);\n    }catch(e){\n        logger.error(e);\n    }\n})\n\nmodule.exports = {\n    clientStore,\n    tokenStore,\n    logger\n}","const fetch = require('node-fetch');\n\nexport function getFormatedMessage(op, data) {\n    return JSON.stringify({\n        op,\n        data\n    })\n}\n\nexport function sanetizeUrl(url) {\n    if (!url) throw new Error(\"Url is empty\");\n    if (url.substr(url.length - 1) == '/') {\n        return url.substr(0, url.length - 1)\n    } else return url;\n}\n\n\nexport async function fetchData(url, options) {\n    const resp = await fetch(url, options)\n    const json = await resp.json();\n    return json;\n}\n\nexport function checkSlash(baseUrl) {\n    if (!baseUrl) throw new Error(\"HS-AUTH-NODE-SDK:: Error: baseUrl is null or empty\");\n    baseUrl = baseUrl.trim();\n    if (!baseUrl.endsWith('/'))\n        return baseUrl + '/';\n    else\n        return baseUrl;\n}\n\nexport function extractToken(req) {\n    if (req.headers.authorization && req.headers.authorization.split(' ')[0] === 'Bearer') {\n        return req.headers.authorization.split(' ')[1];\n    }\n    return null;\n}\n\nexport function extractRfToken(req) {\n    // TODO:  need to find out what is the proper way of sending a refresh token, \n    // we are sending via \"refresh_token\": \"Bearer <Refresh token>\" header\n    if (req.headers.refreshtoken && req.headers.refreshtoken.split(' ')[0] === 'Bearer') {\n        return req.headers.refreshtoken.split(' ')[1];\n    }\n    return null;\n}\n\n\nexport function responseMessageFormat(success, message, data = {}) {\n    return {\n        hypersign: {\n            success,\n            message,\n            data\n        }\n    }\n}\n\nexport function isDate (date){\n    return (new Date(date) !== \"Invalid Date\") && !isNaN(new Date(date));\n}","module.exports = __WEBPACK_EXTERNAL_MODULE__2__;","const HSWebsocket = require('./hsWebsocket');\nconst HypersignAuthService = require('./hsAuthService');\nconst fs = require('fs');\nconst path = require('path');\nconst { clientStore, logger } = require('./config');\nconst { extractToken, extractRfToken, responseMessageFormat, isDate } = require('./utils');\n\n\nconst HYPERSIGN_CONFIG_FILE = 'hypersign.json';\n\nmodule.exports = class HypersignAuth {\n\n    constructor(server, offlineSigner) {\n        ////\n        // Making it backward compatible\n        const hsFilePath = path.join(__dirname, '../../../', HYPERSIGN_CONFIG_FILE);\n        const hsFilePathDev = path.join(__dirname, '../', HYPERSIGN_CONFIG_FILE)\n        if (!fs.existsSync(hsFilePath) && !fs.existsSync(hsFilePathDev)) throw new Error('HS-AUTH-NODE-SDK:: Error: ' + HYPERSIGN_CONFIG_FILE + ' file does not exist. Generate ' + HYPERSIGN_CONFIG_FILE + ' file from the developer dashboard; filePath = ' + hsFilePath);\n\n        const hypersignConfig = fs.readFileSync(HYPERSIGN_CONFIG_FILE);\n\n        const hsConfigJson = JSON.parse(hypersignConfig);\n\n        // TODO: we can delete this later. this is to make backward compatibility\n        hsConfigJson.appCredential.credentialSubject.authResourcePath = !hsConfigJson.appCredential.credentialSubject.authResourcePath ? \"hs/api/v2/auth\" : hsConfigJson.appCredential.credentialSubject.authResourcePath;\n        hsConfigJson.appCredential.credentialSubject.baseUrl = !hsConfigJson.appCredential.credentialSubject.baseUrl ? hsConfigJson.appCredential.credentialSubject.serviceEp : hsConfigJson.appCredential.credentialSubject.baseUrl;\n\n\n        if (hsConfigJson.keys == {}) throw new Error('HS-AUTH-NODE-SDK:: Error: Cryptographic keys is not set');\n        if (hsConfigJson.networkUrl == \"\") throw new Error('HS-AUTH-NODE-SDK:: Error: Network RPC Url is not set');\n        if (hsConfigJson.networkRestUrl == \"\") throw new Error('HS-AUTH-NODE-SDK:: Error: Network REST Url is not set');\n        if (hsConfigJson.appCredential == {}) throw new Error('HS-AUTH-NODE-SDK:: Error: App Credential is not set');\n        if (hsConfigJson.appCredential.credentialSubject == {}) throw new Error('HS-AUTH-NODE-SDK:: Error: Invalid credentialSubject');\n        if (!hsConfigJson.appCredential.credentialSubject.baseUrl) throw new Error(\"HS-AUTH-NODE-SDK:: Error: BaseUrl is not present in hypersign.json\");\n        if (!hsConfigJson.appCredential.credentialSubject.authResourcePath) throw new Error(\"HS-AUTH-NODE-SDK:: Error: AuthResourcePath is not present in hypersign.json\");\n        if(!hsConfigJson.namespace) {\n            logger.debug('HS-AUTH::DID namespace is not passed. Continuing with mainnet')\n        }\n\n        this.options = {\n            keys: {},\n            mail: {},\n            jwt: {},\n            rft: {},\n            appCredential: {},\n            offlineSigner,\n            namespace:\"\",\n        };\n        Object.assign(this.options.mail, hsConfigJson.mail);\n        Object.assign(this.options.keys, hsConfigJson.keys);\n        Object.assign(this.options.appCredential, hsConfigJson.appCredential);\n\n        this.options.networkUrl = hsConfigJson.networkUrl;\n        this.options.hidNodeRestURL = hsConfigJson.networkRestUrl;\n        this.options.namespace = hsConfigJson.namespace;\n\n        this.options.schemaId = hsConfigJson.appCredential.credentialSubject.schemaId;\n        this.options.developerDashboardUrl = hsConfigJson.developerDashboardUrl ? hsConfigJson.developerDashboardUrl : 'https://ssi.hypermine.in/developer/';\n\n        if (!hsConfigJson.jwt) {\n            const jwtDefault = {\n                secret: 'BadsecretKey1@',\n                expiryTime: '900s' // epires in 15 mins\n            }\n            Object.assign(this.options.jwt, jwtDefault)\n            logger.debug('HS-AUTH:: JWT configuration not passed. Taking default configuration.. Secret = ' + jwtDefault.secret + ' ExpiryTime = ' + jwtDefault.expiryTime)\n        } else {\n            Object.assign(this.options.jwt, hsConfigJson.jwt)\n        }\n        if (!hsConfigJson.rft) {\n            const rftDefault = {\n                secret: 'BadsecretKey1@',\n                expiryTime: '900s' // epires in 15 mins\n            }\n            Object.assign(this.options.rft, rftDefault)\n            logger.debug('HS-AUTH:: Refresh Token configuration not passed. Taking default configuration.. Secret = ' + rftDefault.secret + ' ExpiryTime = ' + rftDefault.expiryTime)\n        } else {\n            Object.assign(this.options.rft, hsConfigJson.rft)\n        }\n\n        this.ws = new HSWebsocket(server,\n            hsConfigJson.appCredential.credentialSubject.baseUrl,\n            hsConfigJson.appCredential.credentialSubject.did,\n            hsConfigJson.appCredential.credentialSubject.name,\n            this.options.schemaId,\n            hsConfigJson.socketConnTimeOut,\n            hsConfigJson.appCredential.credentialSubject.authResourcePath);\n        this.ws.initiate();\n\n        this.options[\"isSubcriptionEnabled\"] = hsConfigJson[\"isSubcriptionEnabled\"] != undefined ? hsConfigJson[\"isSubcriptionEnabled\"] : true;\n\n    }\n\n    async init() {\n        this.middlewareService = new HypersignAuthService(this.options, this.options.appCredential.credentialSubject.baseUrl);\n        await this.middlewareService.init();\n    }\n\n    /**\n     * Authenticate a user by verifying verifiable presentation sent by a user via wallet\n     * @param { Request } req \n     * @param { Response } res \n     * @param { Next } next \n     */\n    async authenticate(req, res, next) {\n        try {\n            const data = await this.middlewareService.authenticate(req.body);\n            Object.assign(req.body, {...responseMessageFormat(true, \"Authenticated successfully\", {...data }) });\n            next();\n        } catch (e) {\n            logger.error(e)\n            res.status(401).send(responseMessageFormat(false, e.message));\n        }\n    }\n\n    /**\n     * Generates accessToken and refreshToken pair \n     * Ref: https://www.rfc-editor.org/rfc/rfc6749#section-6\n     * @param { Request } req \n     * @param { Response } res \n     * @param { Next } next  \n     */\n    async refresh(req, res, next) {\n        try {\n            const refreshToken = extractRfToken(req);\n            if (!refreshToken) throw new Error(\"HS-AUTH-NODE-SDK:: Error: Unauthorized: Refresh Token is not sent in header\")\n\n            const newtokens = await this.middlewareService.refresh(refreshToken);\n            Object.assign(req.body, {...responseMessageFormat(true, \"New pair of tokens\", {...newtokens }) });\n            next()\n        } catch (error) {\n            logger.error(error.message)\n            res.status(401).send(responseMessageFormat(false, e.message));\n        }\n    }\n\n    /**\n     * Logs out a user\n     * @param { Request } req \n     * @param { Response } res \n     * @param { Next } next  \n     */\n    async logout(req, res, next) {\n        try {\n            const refreshToken = extractRfToken(req);\n            if (!refreshToken) throw new Error(\"HS-AUTH-NODE-SDK:: Error: Unauthorized: Refresh Token is not sent in header\")\n\n            await this.middlewareService.logout(refreshToken);\n            // everthing is ok but there is no content\n            res.status(204).send();\n        } catch (error) {\n            logger.error(error.message)\n            res.status(401).send(responseMessageFormat(false, e.message));\n        }\n    }\n\n    /**\n     * Verifies accessToken and returns payload\n     * @param { Request } req \n     * @param { Response } res \n     * @param { Next } next  \n     */\n    async authorize(req, res, next) {\n        try {\n            const authToken = extractToken(req);\n            if (!authToken) throw new Error('HS-AUTH-NODE-SDK:: Error: Authorization token is not passed in the header')\n            const userData = await this.middlewareService.authorize(authToken)\n            Object.assign(req.body, {...responseMessageFormat(true, \"Authorized successfully\", {...userData }) });\n            next();\n        } catch (e) {\n            logger.error(e)\n            res.status(403).send(responseMessageFormat(false, e.message));\n        }\n    }\n\n\n    /**\n     * Registers a new user and sends email\n     * @param { Request } req \n     * @param { Response } res \n     * @param { Next } next \n     */\n    async register(req, res, next) {\n        try {\n            const { user, isThridPartyAuth, expirationDate } = req.body;\n            if(!expirationDate){\n                return res.status(400).send(responseMessageFormat(false, 'Creadential expirationDate must be passed'));\n            }\n            if(!isDate(expirationDate)){\n                return res.status(400).send(responseMessageFormat(false, 'Invalid expirationDate; It must be a datetime field'));\n            }\n            if (!user) {\n                return res.status(400).send(responseMessageFormat(false, 'user object is not passed in the body'));\n            }\n            const vc = await this.middlewareService.register(user, isThridPartyAuth ? isThridPartyAuth : false, expirationDate);\n            if (vc) {\n                Object.assign(req.body, {...responseMessageFormat(true, \"Verifiable Credential\", {...vc }) });\n            }\n            next();\n        } catch (e) {\n            logger.error(e)\n            res.status(500).send(responseMessageFormat(false, e.message));\n        }\n    }\n\n    /**\n     * Verifies the verifiable credential  JWT and issues auth verifiable credential\n     * @param { Request } req \n     * @param { Response } res \n     * @param { Next } next \n     */\n    async issueCredential(req, res, next) {\n        try {\n            const authToken = req.query.token;\n            const userDid = req.query.did\n            if (!authToken) {\n                return res.status(400).send(responseMessageFormat(false, 'token is not passed in the in query'));\n            }\n\n            if (!userDid) {\n                return res.status(400).send(responseMessageFormat(false, 'did is not passed in the in query'));\n            }\n\n            const vc = await this.middlewareService.getCredential(authToken, userDid);\n            Object.assign(req.body, {...responseMessageFormat(true, \"Verifiable Credential\", {...vc }) });\n            next();\n        } catch (e) {\n            logger.error(e)\n            res.status(500).send(responseMessageFormat(false, e.message));\n        }\n    }\n\n    /**\n     * Generates QR data (with challenge) in case the service provider does not want to uee websocket and go with polling\n     * @param { Request } req \n     * @param { Response } res \n     * @param { Next } next  \n     */\n    async challenge(req, res, next) {\n        try {\n            const clientId = clientStore.addClient(null);\n            clientStore.emit('startTimer', { clientId: clientId, time: 120000 });\n            const QRData = this.ws.getQRData(clientId);\n            Object.assign(req.body, {...responseMessageFormat(true, \"New session data\", QRData) })\n            next();\n        } catch (e) {\n            res.status(400).send(responseMessageFormat(false, e.message));\n        }\n    }\n\n    /**\n     * Call this to check if a user has authenticated or not via wallet\n     * @param { Request } req \n     * @param { Response } res \n     * @param { Next } next  \n     */\n    async poll(req, res, next) {\n        try {\n            let challenge;\n            if (req.query && req.query.challenge) {\n                challenge = req.query.challenge;\n            } else if (req.body && req.body.challenge) {\n                challenge = req.body.challenge;\n            }\n            if (!challenge) {\n                return res.status(400).send(responseMessageFormat(false, \"Challenge is not passed in the request body or query parameter\"))\n            }\n            const tokens = await this.middlewareService.poll({ challenge });\n            Object.assign(req.body, {...responseMessageFormat(true, 'User is authenticated', {...tokens }) })\n            next();\n        } catch (e) {\n            res.status(401).send(responseMessageFormat(false, e.message));\n        }\n    }\n\n}","const WebSocket = require('websocket')\nconst { clientStore, logger } = require('./config')\nconst { getFormatedMessage, checkSlash } = require('./utils');\n\n\n\nmodule.exports = class HSWebsocket {\n    constructor(server, baseUrl, appDid, appName, schemaId, socketConnectionTimeOut = 60000, authResourcePath) {\n        if (!server) throw new Error('HS-AUTH-NODE-SDK:: Error: Http server is required.')\n        if (!baseUrl) throw new Error('HS-AUTH-NODE-SDK:: Error: Server baseUrl is required.')\n        this.server = server;\n        this.baseUrl = checkSlash(baseUrl);\n        this.appDid = appDid;\n        this.appName = appName;\n        this.schemaId = schemaId;\n        this.socketConnectionTimeOut = socketConnectionTimeOut;\n        this.authResourcePath = authResourcePath.startsWith(\"/\") ? authResourcePath.substring(1) : authResourcePath;\n    }\n\n    getQRData(challenge) {\n        const JSONData = {\n            QRType: 'REQUEST_CRED',\n            serviceEndpoint: this.baseUrl + this.authResourcePath,\n            schemaId: this.schemaId,\n            appDid: this.appDid,\n            appName: this.appName,\n            challenge\n        }\n\n        return JSONData;\n    }\n\n    initiate() {\n        const wss = new WebSocket.server({\n            httpServer: this.server, // Tieing websocket to HTTP server\n            autoAcceptConnections: false\n        })\n        const that = this;\n        wss.on('request', (request) => {\n            const connection = request.accept(null, request.origin)\n            logger.debug(`HS-AUTH:: Client connected`)\n\n            const clientId = clientStore.addClient(connection);\n            clientStore.emit('startTimer', { clientId: clientId, time: this.socketConnectionTimeOut });\n\n            const JSONData = that.getQRData(clientId);\n\n            connection.sendUTF(getFormatedMessage('init', JSONData));\n            connection.on('message', (m) => {\n\n            })\n            connection.on('close', (conn, clientId) => {\n                if (conn == 4001 && clientId) {\n                    clientStore.emit('deleteClient', { clientId });\n                }\n                logger.debug(`HS-AUTH:: Client disconnected`)\n            })\n        })\n    }\n}","module.exports = __WEBPACK_EXTERNAL_MODULE__5__;","const { v4: uuidv4 } = require('uuid');\nconst EventEmitter = require('events');\n\nclass Client {\n  constructor(connection) {\n    this.clientId = uuidv4();\n    this.connection = connection;\n    this.isAuthenticated = false;\n    this.accessToken = null;\n    this.refreshToken = null;\n  }\n}\n\nmodule.exports = class ClientStore extends EventEmitter {\n  constructor() {\n    super();\n    this.clients = {}; //in-mem store\n  }\n\n  addClient(connection) {\n    // if (!connection) throw new Error('Connection is null')\n    const client = new Client(connection);\n    this.clients[client.clientId] = client;\n    return client.clientId;\n  }\n\n  getClient(clientId) {\n    if (!this.clients[clientId]) throw new Error('HS-AUTH-NODE-SDK:: Error: Invalid challenge');\n    return this.clients[clientId];\n  }\n\n  updateClient(clientId, connection, isAuthenticated, accessToken, refreshToken) {\n    if (!this.clients[clientId]) throw new Error('HS-AUTH-NODE-SDK:: Error: Invalid challenge');\n    let updatedClient = this.clients[clientId];\n    if (connection) updatedClient['connection'] = connection;\n    if (isAuthenticated) updatedClient['isAuthenticated'] = isAuthenticated;\n    if (accessToken) updatedClient['accessToken'] = accessToken;\n    if (refreshToken) updatedClient['refreshToken'] = refreshToken;\n    this.clients[clientId] = updatedClient;\n    return updatedClient;\n  }\n\n  deleteClient(clientId) {\n    //if (!this.clients[clientId]) throw new Error('HS-AUTH-NODE-SDK:: Error: Client does not exist')\n    delete this.clients[clientId];\n    return Object.keys(this.clients).length;\n  }\n\n  getAllClientIds() {\n    return Object.keys(this.clients);\n  }\n};\n","module.exports = require(\"events\");","module.exports = class TokenStore {\n  constructor() {\n    this.store = new Map();\n  }\n\n  // seconds to date\n  toDateTime(secs) {\n    const t = new Date(); // Epoch\n    t.setSeconds(t.getSeconds() + secs);\n    return t;\n  }\n\n  // the reason I had to use this becuase When delay is larger than 2147483647 the delay will be set to 1 since\n  // setTimeout using a 32 bit INT to store the delay so the max value allowed would be 2147483647\n  // Ref: https://stackoverflow.com/questions/3468607/why-does-settimeout-break-for-large-millisecond-delay-values\n  triggerDelete(date, func) {\n    const now = new Date().getTime();\n    const then = date.getTime();\n    const diff = Math.max(then - now, 0);\n    if (diff > 0x7fffffff) {\n      //setTimeout limit is MAX_INT32=(2^31-1)\n      setTimeout(function () {\n        this.triggerDelete(date, func);\n      }, 0x7fffffff);\n    } else {\n      setTimeout(func, diff);\n    }\n  }\n\n  // by default ref token never expires in 30s\n  set(key, value, expiryTime = 30) {\n    this.triggerDelete(this.toDateTime(expiryTime), () => {\n      this.delete(key);\n    });\n    return this.store.set(key, value);\n  }\n\n  get(key) {\n    return this.store.get(key);\n  }\n  has(key) {\n    return this.store.has(key);\n  }\n  delete(key) {\n    return this.store.delete(key);\n  }\n};\n","module.exports = __WEBPACK_EXTERNAL_MODULE__9__;","module.exports = __WEBPACK_EXTERNAL_MODULE__10__;","const jwt = require('jsonwebtoken');\nconst {HypersignSSISdk} = require('hs-ssi-sdk');\nconst regMailTemplate = require('./mail/mail.template');\nconst MailService = require('./mail/mail.service');\nconst { clientStore, tokenStore, logger } = require('./config');\nconst { v4: uuid4 } = require('uuid');\nconst { sanetizeUrl, getFormatedMessage, fetchData, responseMessageFormat } = require('./utils');\n\n\nmodule.exports = class HypersignAuthService {\n\n    constructor(options = {}, baseUrl) {\n        this.options = {};\n        this.options.namespace = options && options.namespace ? options.namespace : '';\n        this.options.jwtExpiryTime = options && options.jwt.expiryTime ? options.jwt.expiryTime : 240000;\n        this.options.rftokenExpiryTime = options && options.rft.expiryTime ? options.rft.expiryTime : 1000;\n        this.options.jwtSecret = options && options.jwt.secret ? options.jwt.secret : 'secretKey';\n        this.options.rftokenSecret = options && options.rft.secret ? options.rft.secret : '8e5507e12da789f3c3bd640711378201d658657999384061bb';\n        this.options.hidNodeURL = options && options.networkUrl ? options.networkUrl : \"http://localhost:26657\"\n        this.options.hidNodeRestURL = options && options.hidNodeRestURL ? options.hidNodeRestURL : \"http://localhost:1317\"\n        this.options.mail = options && options.mail ? options.mail : mail;\n\n        if (!options.offlineSigner) {\n            throw new Error('HS-AUTH-NODE-SDK:: Error: OfflineSigner is required for initilizing Hypersign Auth Service')\n        }\n        this.options.offlineSigner = options.offlineSigner\n\n        this.baseUrl = baseUrl;\n        this.baseUrl = sanetizeUrl(this.baseUrl);\n        this.options.hidNodeURL = sanetizeUrl(this.options.hidNodeURL)\n        this.options.hidNodeRestURL = sanetizeUrl(this.options.hidNodeRestURL)\n\n        this.options.keys = options.keys;\n\n        // const hsSdk = new hsSdk({ nodeUrl: this.options.hidNodeURL });\n\n\n        this.options.schemaId = options.schemaId;\n\n        this.options.mail = options.mail;\n\n\n        this.options.appCredential = options.appCredential;\n        this.developerDashboardVerifyApi = `${sanetizeUrl(options.developerDashboardUrl)}/hs/api/v2/subscription/verify`;\n        this.mailService = this.options.mail && this.options.mail.host != \"\" ? new MailService({ ...this.options.mail }) : null;\n        this.apiAuthToken = \"\";\n        this.isSubscriptionSuccess = false;\n        this.isSubcriptionEnabled = options.isSubcriptionEnabled;\n\n        this.verifyResourcePath = this.options.appCredential.credentialSubject.verifyResourcePath != \"\" ?\n            (this.options.appCredential.credentialSubject.verifyResourcePath.startsWith(\"/\") ? this.options.appCredential.credentialSubject.verifyResourcePath : \"/\" + this.options.appCredential.verifyResourcePath) :\n            \"/hs/api/v2/credential\";\n    }\n\n\n    async init() {\n        const hsSdk = new HypersignSSISdk ({offlineSigner: this.options.offlineSigner, nodeRpcEndpoint:this.options.hidNodeURL,nodeRestEndpoint: this.options.hidNodeRestURL, namespace:this.options.namespace});\n        await hsSdk.init();\n        this.hsSdkVC = hsSdk.vc;\n        this.hsSDKVP = hsSdk.vp;\n    }\n\n    /**\n     * Verifies VP\n     * @param { Object } vpObj  // verifiable presentation\n     * @param { String } challenge  // challenge\n     * @returns boolean \n     */\n    async verifyPresentation(vpObj, challenge, holderDidDocSigned) {\n        console.log(\"Verifying presentation\");\n        if (!vpObj) throw new Error('HS-AUTH-NODE-SDK:: Error: presentation is null')\n        if (!challenge) throw new Error('HS-AUTH-NODE-SDK:: Error: challenge is null')\n\n        const vc = vpObj.verifiableCredential[0];\n        console.log(\"vc\", vc);\n        let options\n        if (holderDidDocSigned) {\n            const holderDidDocSignedtemp = JSON.parse(holderDidDocSigned)\n            options = {\n                signedPresentation: vpObj,\n                challenge,\n                domain: \"https://localhos:20202\", //TODO:  need to remove this hardcoding\n                issuerDid: vc.issuer,\n                holderDidDocSigned: holderDidDocSignedtemp,\n                holderVerificationMethodId: vpObj.proof.verificationMethod,\n                issuerVerificationMethodId: vc.issuer + '#key-1'\n            }\n        } else {\n            options = {\n                signedPresentation: vpObj,\n                challenge,\n                domain: \"https://localhos:20202\", //TODO:  need to remove this hardcoding\n                issuerDid: vc.issuer,\n                holderDid: vc.credentialSubject.id,\n                holderVerificationMethodId: vpObj.proof.verificationMethod,\n                issuerVerificationMethodId: vc.issuer + '#key-1'\n            }\n        }\n        const result = await this.hsSDKVP.verify(options)\n        const { verified } = result;\n        return verified;\n    }\n\n    /**\n     * Generates verfiable credentials based on userdata \n     * @param { Object } userData \n     * @returns signed VC\n     */\n    async generateCredential(userData, expirationDate, didDoc) {\n        // const schemaUrl = this.options.hidNodeURL + '/api/v1/schema/' + this.options.schemaId;\n        const schemaId = this.options.schemaId;\n        const issuerKeys = this.options.keys;\n        const { did } = userData;\n\n        // removing unwanted fields since they got added by JWT\n        delete userData['iat'];\n        delete userData['exp'];\n        delete userData['did'];\n\n        logger.debug(\"HS-AUTH:: Credential is being generated...\")\n        let options = {}\n        if (didDoc) {\n            options = {\n                schemaId,\n                subjectDidDocSigned: didDoc,\n                issuerDid: issuerKeys.publicKey.id,\n                expirationDate,\n                fields: userData\n            }\n        } else {\n            options = {\n                schemaId,\n                subjectDid: did,\n                issuerDid: issuerKeys.publicKey.id,\n                expirationDate,\n                fields: userData\n            }\n        }\n        const credential = await this.hsSdkVC.generate(options)\n        logger.debug(\"HS-AUTH:: Credential is being signed...\")\n        const verificationMethodId = issuerKeys.publicKey.id + \"#key-1\";\n        const signOptions = {\n            credential,\n            issuerDid: issuerKeys.publicKey.id,\n            privateKeyMultibase: issuerKeys.privateKeyBase58,\n            verificationMethodId,\n            registerCredential: false,\n        }\n        const signedCredential = await this.hsSdkVC.issue(signOptions)\n        const txn_message = await this.hsSdkVC.generateRegisterCredentialStatusTxnMessage(signedCredential.credentialStatus, signedCredential.credentialStatusProof)\n        signedCredential.txn = txn_message\n        return signedCredential\n    }\n\n    /**\n     * Generates verifiable presentation\n     * @returns signed VP\n     */\n    async generatePresentation() {\n        const issuerKeys = this.options.keys;\n        const presentation = await this.hsSdkVC.generatePresentation(\n            this.options.appCredential,\n            issuerKeys.publicKey.id\n        );\n        const challenge = uuid4();\n        const signedPresentation = await this.hsSdkVC.sign(presentation, issuerKeys.publicKey.id, issuerKeys.privateKeyBase58, challenge)\n        return signedPresentation\n    }\n\n    /**\n     * Calls subscription api to check for plan and subscription\n     */\n    async callSubscriptionAPIwithPresentation() {\n        const data = await this.generatePresentation();\n        const json = await fetchData(this.developerDashboardVerifyApi, {\n            method: 'POST',\n            headers: {\n                \"Content-Type\": \"application/json\",\n            },\n            body: JSON.stringify(data)\n        })\n\n        if (json.status == 200) {\n            this.isSubscriptionSuccess = true;\n            this.apiAuthToken = json.message;\n        } else if (json.status == 401) {\n            throw new Error('HS-AUTH-NODE-SDK:: Error: Unauthorized subscription API access');\n        } else {\n            throw new Error('HS-AUTH-NODE-SDK::Error:' + json.error);\n        }\n    }\n\n    /**\n     * Check for subscription\n     */\n    async checkSubscription() {\n        if (this.apiAuthToken == \"\") {\n            logger.debug('HS-AUTH:: No API Authorization token found, authenticating using verifiable presentation');\n            await this.callSubscriptionAPIwithPresentation();\n        } else {\n            logger.debug('HS-AUTH:: Found API Authorization token, trying to authorize');\n            const developerPortalAPI = `${this.developerDashboardVerifyApi}?apiAuthToken=${this.apiAuthToken}`;\n            const json = await fetchData(developerPortalAPI, {\n                method: 'POST',\n            });\n\n            if (json.status == 200) {\n                this.isSubscriptionSuccess = true;\n            } else if (json.status == 403) {\n                logger.debug('HS-AUTH:: API Authorization token has expired. Trying to authentication again using verifiable presentation');\n                await this.callSubscriptionAPIwithPresentation();\n            } else {\n                throw new Error('HS-AUTH-NODE-SDK::Error:' + json.error);\n            }\n        }\n    }\n\n    /**\n     * Verifies refreshtoken JWT\n     * @param { String } refreshToken \n     * @returns payload\n     */\n    async verifyRefreshToken(refreshToken) {\n        return await jwt.verify(refreshToken, this.options.rftokenSecret)\n    }\n\n    // Public methods\n    /////////////////\n\n    /**\n     * Authenticates user's credentials\n     * @param { object } body \n     * @returns accessToken and refreshToken\n     */\n    async authenticate(body) {\n        const { challenge, vp, holderDidDocSigned } = body;\n        if (this.isSubcriptionEnabled) {\n            await this.checkSubscription();\n            if (!this.isSubscriptionSuccess) throw new Error('HS-AUTH-NODE-SDK:: Error: Subscription check unsuccessfull')\n        }\n\n        const vpObj = JSON.parse(vp);\n        const subject = vpObj['verifiableCredential'][0]['credentialSubject'];\n\n        logger.debug(\"HS-AUTH:: Presentation is being verified...\")\n\n        if (!(await this.verifyPresentation(vpObj, challenge, holderDidDocSigned))) throw new Error('HS-AUTH-NODE-SDK:: Error: Could not verify the presentation')\n\n        // TODO:  need to find out if we are missing any imp parameter in the options.\n        // what is the proper way to JWT sign \n        const accessToken = await jwt.sign(subject, this.options.jwtSecret, { expiresIn: this.options.jwtExpiryTime });\n        const refreshToken = await jwt.sign(subject, this.options.rftokenSecret, { expiresIn: this.options.rftokenExpiryTime })\n\n        // TODO:  once we use redis , we can set the expiration time = this.options.rftokenExpiryTime also\n        // but for in-mem, let;s keep it simple\n        await tokenStore.set(subject.id, refreshToken, this.options.rftokenExpiryTime)\n\n        let client = clientStore.getClient(challenge)\n        const tokens = { accessToken, refreshToken }\n        if (client.connection) {\n            client.connection.sendUTF(getFormatedMessage('end', responseMessageFormat(true, 'User is authenticated', tokens)))\n            client = clientStore.updateClient(challenge, client.connection, true, tokens.accessToken, tokens.refreshToken);\n            clientStore.deleteClient(client.clientId);\n        } else {\n            client = clientStore.updateClient(challenge, null, true, tokens.accessToken, tokens.refreshToken);\n        }\n        logger.debug(\"HS-AUTH:: Finished.\")\n        return {\n            user: subject,\n            ...tokens\n        }\n    }\n\n    /**\n     * Verifies old refresh token and generates a new pair\n     * @param { string } refreshToken \n     * @returns accessToken and refreshToken\n     */\n    async refresh(refreshToken) {\n        const payload = await this.verifyRefreshToken(refreshToken)\n\n        // TODO: we need to check if this refresh token was present in the store.\n        const refTokenStored = await tokenStore.get(payload.id)\n\n        if (refTokenStored != refreshToken) {\n            throw new Error(\"HS-AUTH-NODE-SDK:: Error: Unauthorized: Invalid ref token or expired\")\n        }\n\n        delete payload[\"exp\"]\n        delete payload[\"iat\"]\n        const accessToken = await jwt.sign(payload, this.options.jwtSecret, { expiresIn: this.options.jwtExpiryTime })\n        const refToken = await jwt.sign(payload, this.options.rftokenSecret, { expiresIn: this.options.rftokenExpiryTime })\n\n        // TODO::  store the ref token using key value , user did as key\n        // Store the tokens in key val\n        // TODO:  once we use redis , we can set the expiration time = this.options.rftokenExpiryTime also\n        // but for in-mem, let;s keep it simple\n        await tokenStore.set(payload.id, refToken, this.options.rftokenExpiryTime) // the expirey time is in second\n\n        return {\n            accessToken,\n            refreshToken: refToken\n        }\n    }\n\n    /**\n     * Deletes refresh token for that user\n     * @param { string } refreshToken \n     */\n    async logout(refreshToken) {\n        const payload = await this.verifyRefreshToken(refreshToken)\n        // TODO: delete on logout\n        await tokenStore.delete(payload.id)\n    }\n\n    /**\n     * Verifies JWT accessToken\n     * @param { string } authToken \n     * @returns payload\n     */\n    async authorize(authToken) {\n        return await jwt.verify(authToken, this.options.jwtSecret)\n    }\n\n    /**\n     * Geneartes verifiable credential JWT and sends email\n     * @param { object } user \n     * @param { boolean } isThridPartyAuth \n     * @returns null\n     */\n    async register(user, isThridPartyAuth = false, expirationDate, didDoc) {\n        if (!this.mailService) throw new Error(\"HS-AUTH-NODE-SDK:: Error: Mail configuration is not defined\");\n        if (!this.verifyResourcePath) throw new Error(\"HS-AUTH-NODE-SDK:: Error: VerifyResourcePath is not set in configuration file\")\n\n        if (!user) throw new Error(\"HS-AUTH-NODE-SDK:: Error: User object is null or empty.\")\n\n        if (isThridPartyAuth) {\n            const { did } = user;\n\n            if (!did) throw new Error(\"HS-AUTH-NODE-SDK:: Error: Did must be passed with thirdparty auth request\");\n\n            const verifiableCredential = await this.generateCredential(user, expirationDate, didDoc);\n            return verifiableCredential;\n        }\n\n        const token = await jwt.sign(user, this.options.jwtSecret, { expiresIn: this.options.jwtExpiryTime })\n        let link = `${this.baseUrl}${this.verifyResourcePath}?token=${token}`;\n        let mailTemplate = regMailTemplate;\n        mailTemplate = mailTemplate.replace(/@@APPNAME@@/g, this.options.mail.name);\n        mailTemplate = mailTemplate.replace('@@RECEIVERNAME@@', user.name);\n        mailTemplate = mailTemplate.replace('@@LINK@@', link);\n        const JSONdata = JSON.stringify({\n            QRType: 'ISSUE_CRED',\n            url: link\n        });\n\n        // TODO:  need to remove this hardcoded url\n        const authServerOrigin = (new URL(this.options.hidNodeURL)).origin;\n        const authenticationServerEndPoint = `${authServerOrigin}/hsauth`\n        const deepLinkUrl = encodeURI(`${authenticationServerEndPoint}/deeplink.html?deeplink=hypersign:deeplink?url=${JSONdata}`);\n        mailTemplate = mailTemplate.replace(\"@@DEEPLINKURL@@\", deepLinkUrl);\n\n        if (!user.email) throw new Error(\"HS-AUTH-NODE-SDK:: Error: No email is passed. Email is required property\");\n        const info = await this.mailService.sendEmail(user.email, mailTemplate, `${this.options.mail.name} Auth Credential Issuance`);\n        return null;\n    }\n\n    /**\n     * Verifies VC JWT and Geneartes verifiable credential\n     * @param { string } token \n     * @param { string } userDid \n     * @returns verifiable credential\n     */\n    async getCredential(token, userDid) {\n        const data = await jwt.verify(token, this.options.jwtSecret)\n        data.did = userDid;\n        const verifiableCredential = await this.generateCredential(data);\n        return verifiableCredential\n    }\n\n    async poll({ challenge }) {\n        if (!challenge) {\n            throw new Error(\"HS-AUTH-NODE-SDK:: Error: Challenge must be passed\");\n        }\n        let client = clientStore.getClient(challenge);\n        if (!client) {\n            throw new Error(\"HS-AUTH-NODE-SDK:: Error: Invalid challenge\");\n        }\n        const { isAuthenticated, accessToken, refreshToken } = client;\n        if (isAuthenticated === false) {\n            throw new Error(\"HS-AUTH-NODE-SDK:: Error: Unauthorized\");\n        }\n\n        clientStore.deleteClient(challenge);\n        return { accessToken, refreshToken };\n    }\n}","module.exports = __WEBPACK_EXTERNAL_MODULE__12__;","module.exports = __WEBPACK_EXTERNAL_MODULE__13__;","const template = `\n<html>\n\n<head>\n    <style>\n        .colored {\n            color: blue;\n        }\n\n        #body {\n            background-color: #80808021\n            font-size: 18px;\n            border: 1px solid #80808021;\n            padding:20px;\n        }\n\n        .center{\n            margin: auto;\n            width: 50%;\n        }\n\n        .mobile {\n            display: none;\n        }\n        .web {\n            display:block;\n        }\n        .button {\n            background-color: #272831;\n            /* blakish */\n            border: none;\n            color: #f1f1f1;\n            border-radius: 8px;\n            padding: 20px;\n            text-align: center;\n            text-decoration: none;\n            font-size: 16px;\n            cursor: pointer;\n            width:30%;\n        }\n\n        @media only screen and (max-device-width : 640px) {\n\n            /* Styles */\n            .mobile {\n                display: block;\n            }\n            .web {\n                display:none;\n            }\n        }\n\n        @media only screen and (max-device-width: 768px) {\n\n            /* Styles */\n            .mobile {\n                display: block;\n            }\n            .web {\n                display:none;\n            }\n        }\n    </style>\n</head>\n\n<body>\n    <div id='body' class=\"center\">\n        <p class='center'><h3>Hi @@RECEIVERNAME@@,</h3></p>\n        <p class='center' style='width:100%'><h5>Welcome to @@APPNAME@@!</h5></p>\n        <p class='colored'>\n            @@APPNAME@@ credential is being issued to you. \n        </p>\n        <p class='colored'>Tap 'Get Credential' button (or link) to receieve the credential in your Hypersign Identity Wallet.</p>\n        <br/>\n        <p><a href='@@DEEPLINKURL@@' class=\"button\">Get credential</a></p>\n        <br/>\n        <br/>\n        <p>Thanks & Regards, <br />Team @@APPNAME@@!</p>\n        <p></p>\n    </div>\n</body>\n\n</html>\n`;\nmodule.exports = template;\n","const nodemailer = require('nodemailer');\nconst { logger } = require('../config');\nmodule.exports = class MailService {\n  constructor({ host, port, user, pass, name }) {\n    this.host = host;\n    this.port = port;\n    this.pass = pass;\n    this.user = user;\n    this.name = name;\n\n    this.transporter = nodemailer.createTransport({\n      host: this.host,\n      port: this.port,\n      secure: true, // true for 465, false for other ports. TODO: find better way to work with it\n      auth: {\n        user: this.user,\n        pass: this.pass,\n      },\n    });\n\n    this.transporter.verify((err, success) => {\n      if (err) console.error(err);\n      logger.debug('HS-AUTH:: Your config is correct');\n    });\n  }\n\n  async sendEmail(to, message, subject) {\n    const info = await this.transporter.sendMail({\n      from: `${this.name} <${this.user}>`,\n      to,\n      subject: 'No reply: ' + subject,\n      html: message,\n    });\n    return info;\n  }\n};\n","module.exports = __WEBPACK_EXTERNAL_MODULE__16__;","module.exports = require(\"fs\");","module.exports = require(\"path\");"],"sourceRoot":""}