!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t(require("uuid"),require("websocket"),require("simple-node-logger"),require("node-fetch"),require("jsonwebtoken"),require("hs-ssi-sdk"),require("nodemailer")):"function"==typeof define&&define.amd?define([,,,,,,],t):"object"==typeof exports?exports.Ae=t(require("uuid"),require("websocket"),require("simple-node-logger"),require("node-fetch"),require("jsonwebtoken"),require("hs-ssi-sdk"),require("nodemailer")):e.Ae=t(e[void 0],e[void 0],e[void 0],e[void 0],e[void 0],e[void 0],e[void 0])}(global,(function(t,i,n,s,r,o,a){return function(e){var t={};function i(n){if(t[n])return t[n].exports;var s=t[n]={i:n,l:!1,exports:{}};return e[n].call(s.exports,s,s.exports,i),s.l=!0,s.exports}return i.m=e,i.c=t,i.d=function(e,t,n){i.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},i.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},i.t=function(e,t){if(1&t&&(e=i(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(i.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var s in e)i.d(n,s,function(t){return e[t]}.bind(null,s));return n},i.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return i.d(t,"a",t),t},i.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},i.p="",i(i.s=3)}([function(e,t,i){const n=i(6),s=i(8),r=i(9),{getFormatedMessage:o}=i(1),a=new n,c=new s,l=r.createSimpleLogger({logFilePath:"hypersign-auth.log",timestampFormat:"YYYY-MM-DD HH:mm:ss.SSS"});l.setLevel("debug"),a.on("startTimer",e=>{try{const{clientId:t,time:i}=e,{connection:n}=a.getClient(t);setTimeout(()=>{n&&n.sendUTF(o("reload",{clientId:t})),a.emit("deleteClient",{clientId:t})},i)}catch(e){l.error(e)}}),a.on("deleteClient",e=>{try{const{clientId:t}=e;a.deleteClient(t)}catch(e){l.error(e)}}),e.exports={clientStore:a,tokenStore:c,logger:l}},function(e,t,i){"use strict";i.r(t),i.d(t,"getFormatedMessage",(function(){return s})),i.d(t,"sanetizeUrl",(function(){return r})),i.d(t,"fetchData",(function(){return o})),i.d(t,"checkSlash",(function(){return a})),i.d(t,"extractToken",(function(){return c})),i.d(t,"extractRfToken",(function(){return l})),i.d(t,"responseMessageFormat",(function(){return h}));const n=i(10);function s(e,t){return JSON.stringify({op:e,data:t})}function r(e){if(!e)throw new Error("Url is empty");return"/"==e.substr(e.length-1)?e.substr(0,e.length-1):e}async function o(e,t){const i=await n(e,t);return await i.json()}function a(e){if(!e)throw new Error("baseUrl is null or empty");return(e=e.trim()).endsWith("/")?e:e+"/"}function c(e){return e.headers.authorization&&"Bearer"===e.headers.authorization.split(" ")[0]?e.headers.authorization.split(" ")[1]:null}function l(e){return e.headers.refreshtoken&&"Bearer"===e.headers.refreshtoken.split(" ")[0]?e.headers.refreshtoken.split(" ")[1]:null}function h(e,t,i={}){return{hypersign:{success:e,message:t,data:i}}}},function(e,i){e.exports=t},function(t,i,n){const s=n(4),r=n(11),o=n(17),a=n(18),{clientStore:c,logger:l}=n(0),{extractToken:h,extractRfToken:d,responseMessageFormat:u}=n(1);t.exports=class{constructor(e,t){const i=a.join(__dirname,"../../../","hypersign.json"),n=a.join(__dirname,"../","hypersign.json");if(!o.existsSync(i)&&!o.existsSync(n))throw new Error("hypersign.json file does not exist. Generate hypersign.json file from the developer dashboard; filePath = "+i);const r=o.readFileSync("hypersign.json"),c=JSON.parse(r);if(c.appCredential.credentialSubject.authResourcePath=c.appCredential.credentialSubject.authResourcePath?c.appCredential.credentialSubject.authResourcePath:"hs/api/v2/auth",c.appCredential.credentialSubject.baseUrl=c.appCredential.credentialSubject.baseUrl?c.appCredential.credentialSubject.baseUrl:c.appCredential.credentialSubject.serviceEp,c.keys=={})throw new Error("Cryptographic keys is not set");if(""==c.networkUrl)throw new Error("Network RPC Url is not set");if(""==c.networkRestUrl)throw new Error("Network REST Url is not set");if(c.appCredential=={})throw new Error("App Credential is not set");if(c.appCredential.credentialSubject=={})throw new Error("Invalid credentialSubject");if(!c.appCredential.credentialSubject.baseUrl)throw new Error("BaseUrl is not present in hypersign.json");if(!c.appCredential.credentialSubject.authResourcePath)throw new Error("AuthResourcePath is not present in hypersign.json");if(this.options={keys:{},mail:{},jwt:{},rft:{},appCredential:{},offlineSigner:t},Object.assign(this.options.mail,c.mail),Object.assign(this.options.keys,c.keys),Object.assign(this.options.appCredential,c.appCredential),this.options.networkUrl=c.networkUrl,this.options.hidNodeRestURL=c.networkRestUrl,this.options.schemaId=c.appCredential.credentialSubject.schemaId,this.options.developerDashboardUrl=c.developerDashboardUrl?c.developerDashboardUrl:"https://ssi.hypermine.in/developer/",c.jwt)Object.assign(this.options.jwt,c.jwt);else{const e={secret:"BadsecretKey1@",expiryTime:"900s"};Object.assign(this.options.jwt,e),l.debug("HS-AUTH:: JWT configuration not passed. Taking default configuration.. Secret = "+e.secret+" ExpiryTime = "+e.expiryTime)}if(c.rft)Object.assign(this.options.rft,c.rft);else{const e={secret:"BadsecretKey1@",expiryTime:"900s"};Object.assign(this.options.rft,e),l.debug("HS-AUTH:: Refresh Token configuration not passed. Taking default configuration.. Secret = "+e.secret+" ExpiryTime = "+e.expiryTime)}this.ws=new s(e,c.appCredential.credentialSubject.baseUrl,c.appCredential.credentialSubject.did,c.appCredential.credentialSubject.name,this.options.schemaId,c.socketConnTimeOut,c.appCredential.credentialSubject.authResourcePath),this.ws.initiate(),this.options.isSubcriptionEnabled=null==c.isSubcriptionEnabled||c.isSubcriptionEnabled}async init(){this.middlewareService=new r(this.options,this.options.appCredential.credentialSubject.baseUrl),await this.middlewareService.init()}async authenticate(e,t,i){try{const t=await this.middlewareService.authenticate(e.body);Object.assign(e.body,{...u(!0,"Authenticated successfully",{...t})}),i()}catch(e){l.error(e),t.status(401).send(u(!1,e.message))}}async refresh(t,i,n){try{const e=d(t);if(!e)throw new Error("Unauthorized: Refresh Token is not sent in header");const i=await this.middlewareService.refresh(e);Object.assign(t.body,{...u(!0,"New pair of tokens",{...i})}),n()}catch(t){l.error(t.message),i.status(401).send(u(!1,e.message))}}async logout(t,i,n){try{const e=d(t);if(!e)throw new Error("Unauthorized: Refresh Token is not sent in header");await this.middlewareService.logout(e),i.status(204).send()}catch(t){l.error(t.message),i.status(401).send(u(!1,e.message))}}async authorize(e,t,i){try{const t=h(e);if(!t)throw new Error("Authorization token is not passed in the header");const n=await this.middlewareService.authorize(t);Object.assign(e.body,{...u(!0,"Authorized successfully",{...n})}),i()}catch(e){l.error(e),t.status(403).send(u(!1,e.message))}}async register(e,t,i){try{const{user:n,isThridPartyAuth:s}=e.body;if(!n)return t.status(400).send(u(!1,"user object is not passed in the body"));const r=await this.middlewareService.register(n,s||!1);r&&Object.assign(e.body,{...u(!0,"Verifiable Credential",{...r})}),i()}catch(e){l.error(e),t.status(500).send(u(!1,e.message))}}async issueCredential(e,t,i){try{const n=e.query.token,s=e.query.did;if(!n)return t.status(400).send(u(!1,"token is not passed in the in query"));if(!s)return t.status(400).send(u(!1,"did is not passed in the in query"));const r=await this.middlewareService.getCredential(n,s);Object.assign(e.body,{...u(!0,"Verifiable Credential",{...r})}),i()}catch(e){l.error(e),t.status(500).send(u(!1,e.message))}}async challenge(e,t,i){try{const t=c.addClient(null);c.emit("startTimer",{clientId:t,time:12e4});const n=this.ws.getQRData(t);Object.assign(e.body,{...u(!0,"New session data",n)}),i()}catch(e){t.status(400).send(u(!1,e.message))}}async poll(e,t,i){try{let n;if(e.query&&e.query.challenge?n=e.query.challenge:e.body&&e.body.challenge&&(n=e.body.challenge),!n)return t.status(400).send(u(!1,"Challenge is not passed in the request body or query parameter"));const s=await this.middlewareService.poll({challenge:n});Object.assign(e.body,{...u(!0,"User is authenticated",{...s})}),i()}catch(e){t.status(401).send(u(!1,e.message))}}}},function(e,t,i){const n=i(5),{clientStore:s,logger:r}=i(0),{getFormatedMessage:o,checkSlash:a}=i(1);e.exports=class{constructor(e,t,i,n,s,r=6e4,o){if(!e)throw new Error("Http server is required.");if(!t)throw new Error("Server baseUrl is required.");this.server=e,this.baseUrl=a(t),this.appDid=i,this.appName=n,this.schemaId=s,this.socketConnectionTimeOut=r,this.authResourcePath=o.startsWith("/")?o.substring(1):o}getQRData(e){return{QRType:"REQUEST_CRED",serviceEndpoint:this.baseUrl+this.authResourcePath,schemaId:this.schemaId,appDid:this.appDid,appName:this.appName,challenge:e}}initiate(){const e=new n.server({httpServer:this.server,autoAcceptConnections:!1}),t=this;e.on("request",e=>{const i=e.accept(null,e.origin);r.debug("HS-AUTH:: Client connected");const n=s.addClient(i);s.emit("startTimer",{clientId:n,time:this.socketConnectionTimeOut});const a=t.getQRData(n);i.sendUTF(o("init",a)),i.on("message",e=>{}),i.on("close",(e,t)=>{4001==e&&t&&s.emit("deleteClient",{clientId:t}),r.debug("HS-AUTH:: Client disconnected")})})}}},function(e,t){e.exports=i},function(e,t,i){const{v4:n}=i(2),s=i(7);class r{constructor(e){this.clientId=n(),this.connection=e,this.isAuthenticated=!1,this.accessToken=null,this.refreshToken=null}}e.exports=class extends s{constructor(){super(),this.clients={}}addClient(e){const t=new r(e);return this.clients[t.clientId]=t,t.clientId}getClient(e){if(!this.clients[e])throw new Error("Invalid challenge");return this.clients[e]}updateClient(e,t,i,n,s){if(!this.clients[e])throw new Error("Invalid challenge");let r=this.clients[e];return t&&(r.connection=t),i&&(r.isAuthenticated=i),n&&(r.accessToken=n),s&&(r.refreshToken=s),this.clients[e]=r,r}deleteClient(e){return delete this.clients[e],Object.keys(this.clients).length}getAllClientIds(){return Object.keys(this.clients)}}},function(e,t){e.exports=require("events")},function(e,t){e.exports=class{constructor(){this.store=new Map}toDateTime(e){const t=new Date;return t.setSeconds(t.getSeconds()+e),t}triggerDelete(e,t){const i=(new Date).getTime(),n=e.getTime(),s=Math.max(n-i,0);s>2147483647?setTimeout((function(){this.triggerDelete(e,t)}),2147483647):setTimeout(t,s)}set(e,t,i=30){return this.triggerDelete(this.toDateTime(i),()=>{this.delete(e)}),this.store.set(e,t)}get(e){return this.store.get(e)}has(e){return this.store.has(e)}delete(e){return this.store.delete(e)}}},function(e,t){e.exports=n},function(e,t){e.exports=s},function(e,t,i){const n=i(12),s=i(13),r=i(14),o=i(15),{clientStore:a,tokenStore:c,logger:l}=i(0),{v4:h}=i(2),{sanetizeUrl:d,getFormatedMessage:u,fetchData:p,responseMessageFormat:f}=i(1);e.exports=class{constructor(e={},t){if(this.options={},this.options.jwtExpiryTime=e&&e.jwt.expiryTime?e.jwt.expiryTime:24e4,this.options.rftokenExpiryTime=e&&e.rft.expiryTime?e.rft.expiryTime:1e3,this.options.jwtSecret=e&&e.jwt.secret?e.jwt.secret:"secretKey",this.options.rftokenSecret=e&&e.rft.secret?e.rft.secret:"8e5507e12da789f3c3bd640711378201d658657999384061bb",this.options.hidNodeURL=e&&e.networkUrl?e.networkUrl:"http://localhost:26657",this.options.hidNodeRestURL=e&&e.networkRestUrl?e.networkRestUrl:"http://localhost:1317",this.options.mail=e&&e.mail?e.mail:mail,!e.offlineSigner)throw new Error("OfflineSigner is required for initilizing Hypersign Auth Service");this.options.offlineSigner=e.offlineSigner,this.baseUrl=t,this.baseUrl=d(this.baseUrl),this.options.hidNodeURL=d(this.options.hidNodeURL),this.options.hidNodeRestURL=d(this.options.hidNodeRestURL),this.options.keys=e.keys,this.options.schemaId=e.schemaId,this.options.mail=e.mail,this.options.appCredential=e.appCredential,this.developerDashboardVerifyApi=d(e.developerDashboardUrl)+"/hs/api/v2/subscription/verify",this.mailService=this.options.mail&&""!=this.options.mail.host?new o({...this.options.mail}):null,this.apiAuthToken="",this.isSubscriptionSuccess=!1,this.isSubcriptionEnabled=e.isSubcriptionEnabled,this.verifyResourcePath=""!=this.options.appCredential.credentialSubject.verifyResourcePath?this.options.appCredential.credentialSubject.verifyResourcePath.startsWith("/")?this.options.appCredential.credentialSubject.verifyResourcePath:"/"+this.options.appCredential.verifyResourcePath:"/hs/api/v2/credential"}async init(){const e=new s(this.options.offlineSigner,this.options.hidNodeURL,this.options.hidNodeRestURL);await e.init(),this.hsSdkVC=e.vc,this.hsSDKVP=e.vp}async verifyPresentation(e,t){if(!e)throw new Error("presentation is null");if(!t)throw new Error("challenge is null");const i=e.verifiableCredential[0],n=await this.hsSDKVP.verifyPresentation({signedPresentation:e,challenge:t,domain:"https://localhos:20202",issuerDid:i.issuer,holderDid:i.credentialSubject.id}),{verified:s}=n;return s}async generateCredential(e){const t=this.options.schemaId,i=this.options.keys,{did:n}=e;delete e.iat,delete e.exp,delete e.did,l.debug("HS-AUTH:: Credential is being generated...");const s={schemaId:t,subjectDid:n,issuerDid:i.publicKey.id,expirationDate:(new Date).toISOString(),fields:e},r=await this.hsSdkVC.getCredential(s);l.debug("HS-AUTH:: Credential is being signed...");const o={credential:r,issuerDid:i.publicKey.id,privateKey:i.privateKeyBase58};return await this.hsSdkVC.signCredential(o)}async generatePresentation(){const e=this.options.keys,t=await this.hsSdkVC.generatePresentation(this.options.appCredential,e.publicKey.id),i=h();return await this.hsSdkVC.signPresentation(t,e.publicKey.id,e.privateKeyBase58,i)}async callSubscriptionAPIwithPresentation(){const e=await this.generatePresentation(),t=await p(this.developerDashboardVerifyApi,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(e)});if(200!=t.status)throw 401==t.status?new Error("Unauthorized subscription API access"):new Error(t.error);this.isSubscriptionSuccess=!0,this.apiAuthToken=t.message}async checkSubscription(){if(""==this.apiAuthToken)l.debug("HS-AUTH:: No API Authorization token found, authenticating using verifiable presentation"),await this.callSubscriptionAPIwithPresentation();else{l.debug("HS-AUTH:: Found API Authorization token, trying to authorize");const e=`${this.developerDashboardVerifyApi}?apiAuthToken=${this.apiAuthToken}`,t=await p(e,{method:"POST"});if(200==t.status)this.isSubscriptionSuccess=!0;else{if(403!=t.status)throw new Error(t.error);l.debug("HS-AUTH:: API Authorization token has expired. Trying to authentication again using verifiable presentation"),await this.callSubscriptionAPIwithPresentation()}}}async verifyRefreshToken(e){return await n.verify(e,this.options.rftokenSecret)}async authenticate(e){const{challenge:t,vp:i}=e;if(this.isSubcriptionEnabled&&(await this.checkSubscription(),!this.isSubscriptionSuccess))throw new Error("Subscription check unsuccessfull");const s=JSON.parse(i),r=s.verifiableCredential[0].credentialSubject;if(l.debug("HS-AUTH:: Presentation is being verified..."),!await this.verifyPresentation(s,t))throw new Error("Could not verify the presentation");const o=await n.sign(r,this.options.jwtSecret,{expiresIn:this.options.jwtExpiryTime}),h=await n.sign(r,this.options.rftokenSecret,{expiresIn:this.options.rftokenExpiryTime});await c.set(r.id,h,this.options.rftokenExpiryTime);let d=a.getClient(t);const p={accessToken:o,refreshToken:h};return d.connection?(d.connection.sendUTF(u("end",f(!0,"User is authenticated",p))),d=a.updateClient(t,d.connection,!0,p.accessToken,p.refreshToken),a.deleteClient(d.clientId)):d=a.updateClient(t,null,!0,p.accessToken,p.refreshToken),l.debug("HS-AUTH:: Finished."),{user:r,...p}}async refresh(e){const t=await this.verifyRefreshToken(e);if(await c.get(t.id)!=e)throw new Error("Unauthorized: Invalid ref token or expired");delete t.exp,delete t.iat;const i=await n.sign(t,this.options.jwtSecret,{expiresIn:this.options.jwtExpiryTime}),s=await n.sign(t,this.options.rftokenSecret,{expiresIn:this.options.rftokenExpiryTime});return await c.set(t.id,s,this.options.rftokenExpiryTime),{accessToken:i,refreshToken:s}}async logout(e){const t=await this.verifyRefreshToken(e);await c.delete(t.id)}async authorize(e){return await n.verify(e,this.options.jwtSecret)}async register(e,t=!1){if(!this.mailService)throw new Error("Mail configuration is not defined");if(!this.verifyResourcePath)throw new Error("VerifyResourcePath is not set in configuration file");if(!e)throw new Error("User object is null or empty.");if(t){const{did:t}=e;if(!t)throw new Error("Did must be passed with thirdparty auth request");return await this.generateCredential(e)}const i=await n.sign(e,this.options.jwtSecret,{expiresIn:this.options.jwtExpiryTime});let s=`${this.baseUrl}${this.verifyResourcePath}?token=${i}`,o=r;o=o.replace(/@@APPNAME@@/g,this.options.mail.name),o=o.replace("@@RECEIVERNAME@@",e.name),o=o.replace("@@LINK@@",s);const a=JSON.stringify({QRType:"ISSUE_CRED",url:s}),c=new URL(this.options.hidNodeURL).origin,l=encodeURI(`${c+"/hsauth"}/deeplink.html?deeplink=hypersign:deeplink?url=${a}`);if(o=o.replace("@@DEEPLINKURL@@",l),!e.email)throw new Error("No email is passed. Email is required property");await this.mailService.sendEmail(e.email,o,this.options.mail.name+" Auth Credential Issuance");return null}async getCredential(e,t){const i=await n.verify(e,this.options.jwtSecret);i.did=t;return await this.generateCredential(i)}async poll({challenge:e}){if(!e)throw new Error("Challenge must be passed");let t=a.getClient(e);if(!t)throw new Error("Invalid challenge");const{isAuthenticated:i,accessToken:n,refreshToken:s}=t;if(!1===i)throw new Error("Unauthorized");return a.deleteClient(e),{accessToken:n,refreshToken:s}}}},function(e,t){e.exports=r},function(e,t){e.exports=o},function(e,t){e.exports="\n<html>\n\n<head>\n    <style>\n        .colored {\n            color: blue;\n        }\n\n        #body {\n            background-color: #80808021\n            font-size: 18px;\n            border: 1px solid #80808021;\n            padding:20px;\n        }\n\n        .center{\n            margin: auto;\n            width: 50%;\n        }\n\n        .mobile {\n            display: none;\n        }\n        .web {\n            display:block;\n        }\n        .button {\n            background-color: #272831;\n            /* blakish */\n            border: none;\n            color: #f1f1f1;\n            border-radius: 8px;\n            padding: 20px;\n            text-align: center;\n            text-decoration: none;\n            font-size: 16px;\n            cursor: pointer;\n            width:30%;\n        }\n\n        @media only screen and (max-device-width : 640px) {\n\n            /* Styles */\n            .mobile {\n                display: block;\n            }\n            .web {\n                display:none;\n            }\n        }\n\n        @media only screen and (max-device-width: 768px) {\n\n            /* Styles */\n            .mobile {\n                display: block;\n            }\n            .web {\n                display:none;\n            }\n        }\n    </style>\n</head>\n\n<body>\n    <div id='body' class=\"center\">\n        <p class='center'><h3>Hi @@RECEIVERNAME@@,</h3></p>\n        <p class='center' style='width:100%'><h5>Welcome to @@APPNAME@@!</h5></p>\n        <p class='colored'>\n            @@APPNAME@@ credential is being issued to you. \n        </p>\n        <p class='colored'>Tap 'Get Credential' button (or link) to receieve the credential in your Hypersign Identity Wallet.</p>\n        <br/>\n        <p><a href='@@DEEPLINKURL@@' class=\"button\">Get credential</a></p>\n        <br/>\n        <br/>\n        <p>Thanks & Regards, <br />Team @@APPNAME@@!</p>\n        <p></p>\n    </div>\n</body>\n\n</html>\n"},function(e,t,i){const n=i(16),{logger:s}=i(0);e.exports=class{constructor({host:e,port:t,user:i,pass:r,name:o}){this.host=e,this.port=t,this.pass=r,this.user=i,this.name=o,this.transporter=n.createTransport({host:this.host,port:this.port,secure:!0,auth:{user:this.user,pass:this.pass}}),this.transporter.verify((e,t)=>{e&&console.error(e),s.debug("HS-AUTH:: Your config is correct")})}async sendEmail(e,t,i){return await this.transporter.sendMail({from:`${this.name} <${this.user}>`,to:e,subject:"No reply: "+i,html:t})}}},function(e,t){e.exports=a},function(e,t){e.exports=require("fs")},function(e,t){e.exports=require("path")}])}));
//# sourceMappingURL=hypersign-auth-node-sdk.js.map