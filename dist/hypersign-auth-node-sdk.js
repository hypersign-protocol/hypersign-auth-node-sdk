!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t(require("uuid"),require("websocket"),require("simple-node-logger"),require("node-fetch"),require("jsonwebtoken"),require("hs-ssi-sdk"),require("nodemailer")):"function"==typeof define&&define.amd?define([,,,,,,],t):"object"==typeof exports?exports.Ae=t(require("uuid"),require("websocket"),require("simple-node-logger"),require("node-fetch"),require("jsonwebtoken"),require("hs-ssi-sdk"),require("nodemailer")):e.Ae=t(e[void 0],e[void 0],e[void 0],e[void 0],e[void 0],e[void 0],e[void 0])}(global,(function(t,i,r,n,s,o,a){return function(e){var t={};function i(r){if(t[r])return t[r].exports;var n=t[r]={i:r,l:!1,exports:{}};return e[r].call(n.exports,n,n.exports,i),n.l=!0,n.exports}return i.m=e,i.c=t,i.d=function(e,t,r){i.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},i.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},i.t=function(e,t){if(1&t&&(e=i(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(i.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var n in e)i.d(r,n,function(t){return e[t]}.bind(null,n));return r},i.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return i.d(t,"a",t),t},i.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},i.p="",i(i.s=3)}([function(e,t,i){const r=i(6),n=i(8),s=i(9),{getFormatedMessage:o}=i(1),a=new r,c=new n,d=s.createSimpleLogger({logFilePath:"hypersign-auth.log",timestampFormat:"YYYY-MM-DD HH:mm:ss.SSS"});d.setLevel("debug"),a.on("startTimer",e=>{try{const{clientId:t,time:i}=e,{connection:r}=a.getClient(t);setTimeout(()=>{r&&r.sendUTF(o("reload",{clientId:t})),a.emit("deleteClient",{clientId:t})},i)}catch(e){d.error(e)}}),a.on("deleteClient",e=>{try{const{clientId:t}=e;a.deleteClient(t)}catch(e){d.error(e)}}),e.exports={clientStore:a,tokenStore:c,logger:d}},function(e,t,i){"use strict";i.r(t),i.d(t,"getFormatedMessage",(function(){return n})),i.d(t,"sanetizeUrl",(function(){return s})),i.d(t,"fetchData",(function(){return o})),i.d(t,"checkSlash",(function(){return a})),i.d(t,"extractToken",(function(){return c})),i.d(t,"extractRfToken",(function(){return d})),i.d(t,"responseMessageFormat",(function(){return l})),i.d(t,"isDate",(function(){return h}));const r=i(10);function n(e,t){return JSON.stringify({op:e,data:t})}function s(e){if(!e)throw new Error("Url is empty");return"/"==e.substr(e.length-1)?e.substr(0,e.length-1):e}async function o(e,t){const i=await r(e,t);return await i.json()}function a(e){if(!e)throw new Error("HS-AUTH-NODE-SDK:: Error: baseUrl is null or empty");return(e=e.trim()).endsWith("/")?e:e+"/"}function c(e){return e.headers.authorization&&"Bearer"===e.headers.authorization.split(" ")[0]?e.headers.authorization.split(" ")[1]:null}function d(e){return e.headers.refreshtoken&&"Bearer"===e.headers.refreshtoken.split(" ")[0]?e.headers.refreshtoken.split(" ")[1]:null}function l(e,t,i={}){return{hypersign:{success:e,message:t,data:i}}}function h(e){return"Invalid Date"!==new Date(e)&&!isNaN(new Date(e))}},function(e,i){e.exports=t},function(t,i,r){const n=r(4),s=r(11),o=r(17),a=r(18),{clientStore:c,logger:d}=r(0),{extractToken:l,extractRfToken:h,responseMessageFormat:u,isDate:p}=r(1);t.exports=class{constructor(e,t){const i=a.join(__dirname,"../../../","hypersign.json"),r=a.join(__dirname,"../","hypersign.json");if(!o.existsSync(i)&&!o.existsSync(r))throw new Error("HS-AUTH-NODE-SDK:: Error: hypersign.json file does not exist. Generate hypersign.json file from the developer dashboard; filePath = "+i);const s=o.readFileSync("hypersign.json"),c=JSON.parse(s);if(c.appCredential.credentialSubject.authResourcePath=c.appCredential.credentialSubject.authResourcePath?c.appCredential.credentialSubject.authResourcePath:"hs/api/v2/auth",c.appCredential.credentialSubject.baseUrl=c.appCredential.credentialSubject.baseUrl?c.appCredential.credentialSubject.baseUrl:c.appCredential.credentialSubject.serviceEp,c.keys=={})throw new Error("HS-AUTH-NODE-SDK:: Error: Cryptographic keys is not set");if(""==c.networkUrl)throw new Error("HS-AUTH-NODE-SDK:: Error: Network RPC Url is not set");if(""==c.networkRestUrl)throw new Error("HS-AUTH-NODE-SDK:: Error: Network REST Url is not set");if(c.appCredential=={})throw new Error("HS-AUTH-NODE-SDK:: Error: App Credential is not set");if(c.appCredential.credentialSubject=={})throw new Error("HS-AUTH-NODE-SDK:: Error: Invalid credentialSubject");if(!c.appCredential.credentialSubject.baseUrl)throw new Error("HS-AUTH-NODE-SDK:: Error: BaseUrl is not present in hypersign.json");if(!c.appCredential.credentialSubject.authResourcePath)throw new Error("HS-AUTH-NODE-SDK:: Error: AuthResourcePath is not present in hypersign.json");if(c.namespace||d.debug("HS-AUTH::DID namespace is not passed. Continuing with mainnet"),this.options={keys:{},mail:{},jwt:{},rft:{},appCredential:{},offlineSigner:t,namespace:""},Object.assign(this.options.mail,c.mail),Object.assign(this.options.keys,c.keys),Object.assign(this.options.appCredential,c.appCredential),this.options.networkUrl=c.networkUrl,this.options.hidNodeRestURL=c.networkRestUrl,this.options.namespace=c.namespace,this.options.schemaId=c.appCredential.credentialSubject.schemaId,this.options.developerDashboardUrl=c.developerDashboardUrl?c.developerDashboardUrl:"https://ssi.hypermine.in/developer/",c.jwt)Object.assign(this.options.jwt,c.jwt);else{const e={secret:"BadsecretKey1@",expiryTime:"900s"};Object.assign(this.options.jwt,e),d.debug("HS-AUTH:: JWT configuration not passed. Taking default configuration.. Secret = "+e.secret+" ExpiryTime = "+e.expiryTime)}if(c.rft)Object.assign(this.options.rft,c.rft);else{const e={secret:"BadsecretKey1@",expiryTime:"900s"};Object.assign(this.options.rft,e),d.debug("HS-AUTH:: Refresh Token configuration not passed. Taking default configuration.. Secret = "+e.secret+" ExpiryTime = "+e.expiryTime)}this.ws=new n(e,c.appCredential.credentialSubject.baseUrl,c.appCredential.credentialSubject.did,c.appCredential.credentialSubject.name,this.options.schemaId,c.socketConnTimeOut,c.appCredential.credentialSubject.authResourcePath),this.ws.initiate(),this.options.isSubcriptionEnabled=null==c.isSubcriptionEnabled||c.isSubcriptionEnabled}async init(){this.middlewareService=new s(this.options,this.options.appCredential.credentialSubject.baseUrl),await this.middlewareService.init()}async authenticate(e,t,i){try{const t=await this.middlewareService.authenticate(e.body);Object.assign(e.body,{...u(!0,"Authenticated successfully",{...t})}),i()}catch(e){d.error(e),t.status(401).send(u(!1,e.message))}}async refresh(t,i,r){try{const e=h(t);if(!e)throw new Error("HS-AUTH-NODE-SDK:: Error: Unauthorized: Refresh Token is not sent in header");const i=await this.middlewareService.refresh(e);Object.assign(t.body,{...u(!0,"New pair of tokens",{...i})}),r()}catch(t){d.error(t.message),i.status(401).send(u(!1,e.message))}}async logout(t,i,r){try{const e=h(t);if(!e)throw new Error("HS-AUTH-NODE-SDK:: Error: Unauthorized: Refresh Token is not sent in header");await this.middlewareService.logout(e),i.status(204).send()}catch(t){d.error(t.message),i.status(401).send(u(!1,e.message))}}async authorize(e,t,i){try{const t=l(e);if(!t)throw new Error("HS-AUTH-NODE-SDK:: Error: Authorization token is not passed in the header");const r=await this.middlewareService.authorize(t);Object.assign(e.body,{...u(!0,"Authorized successfully",{...r})}),i()}catch(e){d.error(e),t.status(403).send(u(!1,e.message))}}async register(e,t,i){try{const{user:r,isThridPartyAuth:n,expirationDate:s}=e.body;if(!s)return t.status(400).send(u(!1,"Creadential expirationDate must be passed"));if(!p(s))return t.status(400).send(u(!1,"Invalid expirationDate; It must be a datetime field"));if(!r)return t.status(400).send(u(!1,"user object is not passed in the body"));const o=await this.middlewareService.register(r,n||!1,s);o&&Object.assign(e.body,{...u(!0,"Verifiable Credential",{...o})}),i()}catch(e){d.error(e),t.status(500).send(u(!1,e.message))}}async issueCredential(e,t,i){try{const r=e.query.token,n=e.query.did;if(!r)return t.status(400).send(u(!1,"token is not passed in the in query"));if(!n)return t.status(400).send(u(!1,"did is not passed in the in query"));const s=await this.middlewareService.getCredential(r,n);Object.assign(e.body,{...u(!0,"Verifiable Credential",{...s})}),i()}catch(e){d.error(e),t.status(500).send(u(!1,e.message))}}async challenge(e,t,i){try{const t=c.addClient(null);c.emit("startTimer",{clientId:t,time:12e4});const r=this.ws.getQRData(t);Object.assign(e.body,{...u(!0,"New session data",r)}),i()}catch(e){t.status(400).send(u(!1,e.message))}}async poll(e,t,i){try{let r;if(e.query&&e.query.challenge?r=e.query.challenge:e.body&&e.body.challenge&&(r=e.body.challenge),!r)return t.status(400).send(u(!1,"Challenge is not passed in the request body or query parameter"));const n=await this.middlewareService.poll({challenge:r});Object.assign(e.body,{...u(!0,"User is authenticated",{...n})}),i()}catch(e){t.status(401).send(u(!1,e.message))}}}},function(e,t,i){const r=i(5),{clientStore:n,logger:s}=i(0),{getFormatedMessage:o,checkSlash:a}=i(1);e.exports=class{constructor(e,t,i,r,n,s=6e4,o){if(!e)throw new Error("HS-AUTH-NODE-SDK:: Error: Http server is required.");if(!t)throw new Error("HS-AUTH-NODE-SDK:: Error: Server baseUrl is required.");this.server=e,this.baseUrl=a(t),this.appDid=i,this.appName=r,this.schemaId=n,this.socketConnectionTimeOut=s,this.authResourcePath=o.startsWith("/")?o.substring(1):o}getQRData(e){return{QRType:"REQUEST_CRED",serviceEndpoint:this.baseUrl+this.authResourcePath,schemaId:this.schemaId,appDid:this.appDid,appName:this.appName,challenge:e}}initiate(){const e=new r.server({httpServer:this.server,autoAcceptConnections:!1}),t=this;e.on("request",e=>{const i=e.accept(null,e.origin);s.debug("HS-AUTH:: Client connected");const r=n.addClient(i);n.emit("startTimer",{clientId:r,time:this.socketConnectionTimeOut});const a=t.getQRData(r);i.sendUTF(o("init",a)),i.on("message",e=>{}),i.on("close",(e,t)=>{4001==e&&t&&n.emit("deleteClient",{clientId:t}),s.debug("HS-AUTH:: Client disconnected")})})}}},function(e,t){e.exports=i},function(e,t,i){const{v4:r}=i(2),n=i(7);class s{constructor(e){this.clientId=r(),this.connection=e,this.isAuthenticated=!1,this.accessToken=null,this.refreshToken=null}}e.exports=class extends n{constructor(){super(),this.clients={}}addClient(e){const t=new s(e);return this.clients[t.clientId]=t,t.clientId}getClient(e){if(!this.clients[e])throw new Error("HS-AUTH-NODE-SDK:: Error: Invalid challenge");return this.clients[e]}updateClient(e,t,i,r,n){if(!this.clients[e])throw new Error("HS-AUTH-NODE-SDK:: Error: Invalid challenge");let s=this.clients[e];return t&&(s.connection=t),i&&(s.isAuthenticated=i),r&&(s.accessToken=r),n&&(s.refreshToken=n),this.clients[e]=s,s}deleteClient(e){return delete this.clients[e],Object.keys(this.clients).length}getAllClientIds(){return Object.keys(this.clients)}}},function(e,t){e.exports=require("events")},function(e,t){e.exports=class{constructor(){this.store=new Map}toDateTime(e){const t=new Date;return t.setSeconds(t.getSeconds()+e),t}triggerDelete(e,t){const i=(new Date).getTime(),r=e.getTime(),n=Math.max(r-i,0);n>2147483647?setTimeout((function(){this.triggerDelete(e,t)}),2147483647):setTimeout(t,n)}set(e,t,i=30){return this.triggerDelete(this.toDateTime(i),()=>{this.delete(e)}),this.store.set(e,t)}get(e){return this.store.get(e)}has(e){return this.store.has(e)}delete(e){return this.store.delete(e)}}},function(e,t){e.exports=r},function(e,t){e.exports=n},function(e,t,i){const r=i(12),{HypersignSSISdk:n}=i(13),s=i(14),o=i(15),{clientStore:a,tokenStore:c,logger:d}=i(0),{v4:l}=i(2),{sanetizeUrl:h,getFormatedMessage:u,fetchData:p,responseMessageFormat:f}=i(1);e.exports=class{constructor(e={},t){if(this.options={},this.options.namespace=e&&e.namespace?e.namespace:"",this.options.jwtExpiryTime=e&&e.jwt.expiryTime?e.jwt.expiryTime:24e4,this.options.rftokenExpiryTime=e&&e.rft.expiryTime?e.rft.expiryTime:1e3,this.options.jwtSecret=e&&e.jwt.secret?e.jwt.secret:"secretKey",this.options.rftokenSecret=e&&e.rft.secret?e.rft.secret:"8e5507e12da789f3c3bd640711378201d658657999384061bb",this.options.hidNodeURL=e&&e.networkUrl?e.networkUrl:"http://localhost:26657",this.options.hidNodeRestURL=e&&e.hidNodeRestURL?e.hidNodeRestURL:"http://localhost:1317",this.options.mail=e&&e.mail?e.mail:mail,!e.offlineSigner)throw new Error("HS-AUTH-NODE-SDK:: Error: OfflineSigner is required for initilizing Hypersign Auth Service");this.options.offlineSigner=e.offlineSigner,this.baseUrl=t,this.baseUrl=h(this.baseUrl),this.options.hidNodeURL=h(this.options.hidNodeURL),this.options.hidNodeRestURL=h(this.options.hidNodeRestURL),this.options.keys=e.keys,this.options.schemaId=e.schemaId,this.options.mail=e.mail,this.options.appCredential=e.appCredential,this.developerDashboardVerifyApi=h(e.developerDashboardUrl)+"/hs/api/v2/subscription/verify",this.mailService=this.options.mail&&""!=this.options.mail.host?new o({...this.options.mail}):null,this.apiAuthToken="",this.isSubscriptionSuccess=!1,this.isSubcriptionEnabled=e.isSubcriptionEnabled,this.verifyResourcePath=""!=this.options.appCredential.credentialSubject.verifyResourcePath?this.options.appCredential.credentialSubject.verifyResourcePath.startsWith("/")?this.options.appCredential.credentialSubject.verifyResourcePath:"/"+this.options.appCredential.verifyResourcePath:"/hs/api/v2/credential"}async init(){const e=new n({offlineSigner:this.options.offlineSigner,nodeRpcEndpoint:this.options.hidNodeURL,nodeRestEndpoint:this.options.hidNodeRestURL,namespace:this.options.namespace});await e.init(),this.hsSdkVC=e.vc,this.hsSDKVP=e.vp}async verifyPresentation(e,t,i){if(console.log("Verifying presentation"),!e)throw new Error("HS-AUTH-NODE-SDK:: Error: presentation is null");if(!t)throw new Error("HS-AUTH-NODE-SDK:: Error: challenge is null");const r=e.verifiableCredential[0];let n;if(console.log("vc",r),i){const s=JSON.parse(i);n={signedPresentation:e,challenge:t,domain:"https://localhos:20202",issuerDid:r.issuer,holderDidDocSigned:s,holderVerificationMethodId:e.proof.verificationMethod,issuerVerificationMethodId:r.issuer+"#key-1"}}else n={signedPresentation:e,challenge:t,domain:"https://localhos:20202",issuerDid:r.issuer,holderDid:r.credentialSubject.id,holderVerificationMethodId:e.proof.verificationMethod,issuerVerificationMethodId:r.issuer+"#key-1"};const s=await this.hsSDKVP.verifyPresentation(n),{verified:o}=s;return o}async generateCredential(e,t,i){const r=this.options.schemaId,n=this.options.keys,{did:s}=e;delete e.iat,delete e.exp,delete e.did,d.debug("HS-AUTH:: Credential is being generated...");let o={};o=i?{schemaId:r,subjectDidDocSigned:i,issuerDid:n.publicKey.id,expirationDate:t,fields:e}:{schemaId:r,subjectDid:s,issuerDid:n.publicKey.id,expirationDate:t,fields:e};const a=await this.hsSdkVC.generate(o);d.debug("HS-AUTH:: Credential is being signed...");const c=n.publicKey.id+"#key-1",l={credential:a,issuerDid:n.publicKey.id,privateKeyMultibase:n.privateKeyBase58,verificationMethodId:c,registerCredential:!1},h=await this.hsSdkVC.issue(l),u=await this.hsSdkVC.generateRegisterCredentialStatusTxnMessage(h.credentialStatus,h.credentialStatusProof);return h.txn=u,h}async generatePresentation(){const e=this.options.keys,t=await this.hsSdkVC.generatePresentation(this.options.appCredential,e.publicKey.id),i=l();return await this.hsSdkVC.signPresentation(t,e.publicKey.id,e.privateKeyBase58,i)}async callSubscriptionAPIwithPresentation(){const e=await this.generatePresentation(),t=await p(this.developerDashboardVerifyApi,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(e)});if(200!=t.status)throw 401==t.status?new Error("HS-AUTH-NODE-SDK:: Error: Unauthorized subscription API access"):new Error("HS-AUTH-NODE-SDK::Error:"+t.error);this.isSubscriptionSuccess=!0,this.apiAuthToken=t.message}async checkSubscription(){if(""==this.apiAuthToken)d.debug("HS-AUTH:: No API Authorization token found, authenticating using verifiable presentation"),await this.callSubscriptionAPIwithPresentation();else{d.debug("HS-AUTH:: Found API Authorization token, trying to authorize");const e=`${this.developerDashboardVerifyApi}?apiAuthToken=${this.apiAuthToken}`,t=await p(e,{method:"POST"});if(200==t.status)this.isSubscriptionSuccess=!0;else{if(403!=t.status)throw new Error("HS-AUTH-NODE-SDK::Error:"+t.error);d.debug("HS-AUTH:: API Authorization token has expired. Trying to authentication again using verifiable presentation"),await this.callSubscriptionAPIwithPresentation()}}}async verifyRefreshToken(e){return await r.verify(e,this.options.rftokenSecret)}async authenticate(e){const{challenge:t,vp:i,holderDidDocSigned:n}=e;if(this.isSubcriptionEnabled&&(await this.checkSubscription(),!this.isSubscriptionSuccess))throw new Error("HS-AUTH-NODE-SDK:: Error: Subscription check unsuccessfull");const s=JSON.parse(i),o=s.verifiableCredential[0].credentialSubject;if(d.debug("HS-AUTH:: Presentation is being verified..."),!await this.verifyPresentation(s,t,n))throw new Error("HS-AUTH-NODE-SDK:: Error: Could not verify the presentation");const l=await r.sign(o,this.options.jwtSecret,{expiresIn:this.options.jwtExpiryTime}),h=await r.sign(o,this.options.rftokenSecret,{expiresIn:this.options.rftokenExpiryTime});await c.set(o.id,h,this.options.rftokenExpiryTime);let p=a.getClient(t);const g={accessToken:l,refreshToken:h};return p.connection?(p.connection.sendUTF(u("end",f(!0,"User is authenticated",g))),p=a.updateClient(t,p.connection,!0,g.accessToken,g.refreshToken),a.deleteClient(p.clientId)):p=a.updateClient(t,null,!0,g.accessToken,g.refreshToken),d.debug("HS-AUTH:: Finished."),{user:o,...g}}async refresh(e){const t=await this.verifyRefreshToken(e);if(await c.get(t.id)!=e)throw new Error("HS-AUTH-NODE-SDK:: Error: Unauthorized: Invalid ref token or expired");delete t.exp,delete t.iat;const i=await r.sign(t,this.options.jwtSecret,{expiresIn:this.options.jwtExpiryTime}),n=await r.sign(t,this.options.rftokenSecret,{expiresIn:this.options.rftokenExpiryTime});return await c.set(t.id,n,this.options.rftokenExpiryTime),{accessToken:i,refreshToken:n}}async logout(e){const t=await this.verifyRefreshToken(e);await c.delete(t.id)}async authorize(e){return await r.verify(e,this.options.jwtSecret)}async register(e,t=!1,i,n){if(!this.mailService)throw new Error("HS-AUTH-NODE-SDK:: Error: Mail configuration is not defined");if(!this.verifyResourcePath)throw new Error("HS-AUTH-NODE-SDK:: Error: VerifyResourcePath is not set in configuration file");if(!e)throw new Error("HS-AUTH-NODE-SDK:: Error: User object is null or empty.");if(t){const{did:t}=e;if(!t)throw new Error("HS-AUTH-NODE-SDK:: Error: Did must be passed with thirdparty auth request");return await this.generateCredential(e,i,n)}const o=await r.sign(e,this.options.jwtSecret,{expiresIn:this.options.jwtExpiryTime});let a=`${this.baseUrl}${this.verifyResourcePath}?token=${o}`,c=s;c=c.replace(/@@APPNAME@@/g,this.options.mail.name),c=c.replace("@@RECEIVERNAME@@",e.name),c=c.replace("@@LINK@@",a);const d=JSON.stringify({QRType:"ISSUE_CRED",url:a}),l=new URL(this.options.hidNodeURL).origin,h=encodeURI(`${l+"/hsauth"}/deeplink.html?deeplink=hypersign:deeplink?url=${d}`);if(c=c.replace("@@DEEPLINKURL@@",h),!e.email)throw new Error("HS-AUTH-NODE-SDK:: Error: No email is passed. Email is required property");await this.mailService.sendEmail(e.email,c,this.options.mail.name+" Auth Credential Issuance");return null}async getCredential(e,t){const i=await r.verify(e,this.options.jwtSecret);i.did=t;return await this.generateCredential(i)}async poll({challenge:e}){if(!e)throw new Error("HS-AUTH-NODE-SDK:: Error: Challenge must be passed");let t=a.getClient(e);if(!t)throw new Error("HS-AUTH-NODE-SDK:: Error: Invalid challenge");const{isAuthenticated:i,accessToken:r,refreshToken:n}=t;if(!1===i)throw new Error("HS-AUTH-NODE-SDK:: Error: Unauthorized");return a.deleteClient(e),{accessToken:r,refreshToken:n}}}},function(e,t){e.exports=s},function(e,t){e.exports=o},function(e,t){e.exports="\n<html>\n\n<head>\n    <style>\n        .colored {\n            color: blue;\n        }\n\n        #body {\n            background-color: #80808021\n            font-size: 18px;\n            border: 1px solid #80808021;\n            padding:20px;\n        }\n\n        .center{\n            margin: auto;\n            width: 50%;\n        }\n\n        .mobile {\n            display: none;\n        }\n        .web {\n            display:block;\n        }\n        .button {\n            background-color: #272831;\n            /* blakish */\n            border: none;\n            color: #f1f1f1;\n            border-radius: 8px;\n            padding: 20px;\n            text-align: center;\n            text-decoration: none;\n            font-size: 16px;\n            cursor: pointer;\n            width:30%;\n        }\n\n        @media only screen and (max-device-width : 640px) {\n\n            /* Styles */\n            .mobile {\n                display: block;\n            }\n            .web {\n                display:none;\n            }\n        }\n\n        @media only screen and (max-device-width: 768px) {\n\n            /* Styles */\n            .mobile {\n                display: block;\n            }\n            .web {\n                display:none;\n            }\n        }\n    </style>\n</head>\n\n<body>\n    <div id='body' class=\"center\">\n        <p class='center'><h3>Hi @@RECEIVERNAME@@,</h3></p>\n        <p class='center' style='width:100%'><h5>Welcome to @@APPNAME@@!</h5></p>\n        <p class='colored'>\n            @@APPNAME@@ credential is being issued to you. \n        </p>\n        <p class='colored'>Tap 'Get Credential' button (or link) to receieve the credential in your Hypersign Identity Wallet.</p>\n        <br/>\n        <p><a href='@@DEEPLINKURL@@' class=\"button\">Get credential</a></p>\n        <br/>\n        <br/>\n        <p>Thanks & Regards, <br />Team @@APPNAME@@!</p>\n        <p></p>\n    </div>\n</body>\n\n</html>\n"},function(e,t,i){const r=i(16),{logger:n}=i(0);e.exports=class{constructor({host:e,port:t,user:i,pass:s,name:o}){this.host=e,this.port=t,this.pass=s,this.user=i,this.name=o,this.transporter=r.createTransport({host:this.host,port:this.port,secure:!0,auth:{user:this.user,pass:this.pass}}),this.transporter.verify((e,t)=>{e&&console.error(e),n.debug("HS-AUTH:: Your config is correct")})}async sendEmail(e,t,i){return await this.transporter.sendMail({from:`${this.name} <${this.user}>`,to:e,subject:"No reply: "+i,html:t})}}},function(e,t){e.exports=a},function(e,t){e.exports=require("fs")},function(e,t){e.exports=require("path")}])}));
//# sourceMappingURL=hypersign-auth-node-sdk.js.map